<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>机器学习-深度学习</title>
      <link href="/2023/04/16/machinelearning1/"/>
      <url>/2023/04/16/machinelearning1/</url>
      
        <content type="html"><![CDATA[<ol><li>Regression</li><li>Classification</li><li>CNN</li><li>Self-attention</li><li>Transformer</li><li>GAN</li><li>BERT</li><li>Auto encoder</li><li>Explainable AI</li><li>Model Attack</li><li>Domain Adaptation</li><li>Reinforcement Learning</li><li>Network Compression</li><li>Life-long Learning</li><li>Meta Learning</li></ol><blockquote><p>李宏毅 YouTube Channel：<a href="https://www.youtube.com/c/HungyiLeeNTU">https://www.youtube.com/c/HungyiLeeNTU</a></p></blockquote><hr><h2 id="一、Regression"><a href="#一、Regression" class="headerlink" title="一、Regression"></a>一、Regression</h2><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业课问答</title>
      <link href="/2023/04/01/ji-suan-ji-zhuan-ye-ke-wen-da/"/>
      <url>/2023/04/01/ji-suan-ji-zhuan-ye-ke-wen-da/</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算机组成原理"><a href="#一、计算机组成原理" class="headerlink" title="一、计算机组成原理"></a>一、计算机组成原理</h2><ol><li><p>上溢：双符号位的最高位表示的始终是结果的正负值，两个数进行运算，得到的结果的绝对值超过最大表示范围。两个正数的运算结果超出了数值位的表示的最大范围，所以数值位进位到符号位了，说明，其绝对值超过了表示的最大范围，为上溢。<strong>定点整数之间只会发生上溢</strong>。</p></li><li><p>下溢：两个浮点数运算，得到的结果的绝对值超过最小的表示范围。两个数是负数，这个两个数的运算结果超过了数值位的最小范围，所以数值位上的1被借走了，说明其绝对值超过了表示的最小范围，为下溢。<strong>只有浮点数的运算会发生下溢</strong>。</p></li><li><p>边界对齐：以空间换时间的思路，起始地址要能够被自身长度整除。采用边界对齐后，访问一个字只需要一次访存。</p></li><li><p>存储方式：大端存储和小端存储。</p></li><li><p>大端方式：高字节存储在低地址（顺着存），小端方式：高字节存储在高地址（逆着存）。</p></li><li><p>浮点数加减运算：</p><ul><li><p>对阶：小阶向大阶看齐</p></li><li><p>尾数加减</p></li><li><p>规格化</p><ul><li>左规：尾数的最高位为非有效位时进行左规吧  </li><li>右规：尾数溢出时右规</li></ul></li><li><p>舍入：在右规和对阶的过程中都有可能存在舍入的问题</p></li><li><p>溢出判断：</p><ul><li>阶码上溢：抛出异常</li><li>阶码下溢：按机器0处理</li></ul></li></ul></li><li><p>IEEE 754 标准：阶码用移码表示，尾数用原码表示，隐藏最高位的1。</p></li><li><p>并行进位加法器：加法器的多个进位同时产生（通过进位产生函数和进位传递函数）。</p></li><li><p>计算机的多级存储系统：</p><ul><li>主存-缓存：用来缓解速度压力，完全由硬件实现，缓存是主存的副本</li><li>主存-辅存：用来缓解容量压力，有操作系统和硬件配合实现，主存是辅存的副本</li></ul></li><li><p>硬布线控制器与微程序控制器</p><ul><li>硬布线控制器是用组合逻辑电路来实现控制器中的CU，微程序控制器是用存储程序的思想来实现CU</li><li>硬布线的执行速度块，微程序控制器执行速度慢</li><li>硬布线繁琐，不规整，微程序控制器较规整</li><li>硬布线应用于RISC，微程序控制器应用于CISC</li><li>硬布线不易扩充，微程序控制器易于扩充</li></ul></li><li><p>影响指令流水线的因素</p><ul><li>结构冲突：多条指令在同一时刻争用同一资源（比如取址与取数据争用内存）。</li><li>数据冲突：当指令在流水线中重叠执行时，后面的指令需要用到前面的指令的执行结果，而前面的指令尚未写回导致的冲突。</li><li>控制冲突：如果现在想要执行某条指令，是由之前指令的运行结果决定，而现在那条之前指令的结果还没产生，就导致了控制冲突。（遇到转移指令，或者其他改变PC的指令）</li></ul></li><li><p>增强总线效能的办法</p><ul><li>猝发传输：读写一组连续的字时，只需要给出首地址即可</li><li>总线复用：信号线在不同的时间传输不同的信息</li></ul></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机专业课 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C指针</title>
      <link href="/2023/03/29/c-zhi-zhen/"/>
      <url>/2023/03/29/c-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<h2 id="C语言指针篇"><a href="#C语言指针篇" class="headerlink" title="C语言指针篇"></a>C语言指针篇</h2><h3 id="一、int-p"><a href="#一、int-p" class="headerlink" title="一、int * p"></a>一、int * p</h3><ol><li><p>int * p中变量名是p，类型为int*，整型的指针类型。</p></li><li><p>赋值方式：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a = 5;int * p;p = &amp;a;printf("p = %d\n",p);//p = 6618646 a的地址int * r = &amp;a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可以把存放一个int类型变量的地址赋给一个int * 指针类型的变量。</p></li><li><p>‘=’左边是一个int * 指针类型的变量 ，可以存放放置着int类型数值的地址。</p></li><li><p>‘=’右边是&amp;a，a是int类型的变量数值5，&amp;是取地址符，&amp;a就是拿到int类型a的数值的地址。</p></li></ol><h3 id="二、int-q"><a href="#二、int-q" class="headerlink" title="二、int ** q"></a>二、int ** q</h3><ol><li><p>int ** q中的变量名是q，类型为int ** 。</p></li><li><p>int * 中存放的是int类型数据的地址。</p></li><li><p>int ** 中存放的是int类型数据的地址的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int ** q;q = &amp;p;printf("q = %d\n",q); //q= 6618626 p的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>指向关系：a&lt;—-p&lt;—-q</p></li></ol><h3 id="三、int-m"><a href="#三、int-m" class="headerlink" title="三、int *** m"></a>三、int *** m</h3><ol><li><p>int *** m中变量名是m，类型为<code>int ***</code>。</p></li><li><p>int ***中存放的是int类型的地址的地址的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int *** m;m = &amp;q;printf("m = %d\n",m);//m = 6618606 q的地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="四、指针操作"><a href="#四、指针操作" class="headerlink" title="四、指针操作"></a>四、指针操作</h3><ol><li><p>* 操作就是取值操作，即取出指针变量存放的地址中所存放的数据。</p></li><li><p>分析这种连着好几个*后面跟个变量的表达式，需要从右往左依次抛开</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">***m; 就是* ( * ( * m )))，看的时候需要从最里层一层一层抛开。    *p;先看成*（p）,再从里向外看，首先他有一个变量p，所有直接可以先从内存中拿到p存放的数据6618636(p中的数据)，再找到内存中6618636那片内存，最后取出6618636中的存放数据5(具体数据)***m = 5;先看成 *(*( * (m))),再从里向外看先从内存中拿到m存放的数据6618616(m中的数据)，再从内存中找到6618616那片内存，取出存放的数据6618624(*q中存放的数据)，完成了 * (m)操作，再从内存中找到6618624那片内存，取出存放的数据6618636 ( *( *(m)) 中存放的数据)，完成了 *(* (m)）操作，再从内存中找到6618636 那片内存，取出存放的数据5( *(*( *(m))) 中存放的数据)，完成了 *(*( *(m)))操作， （几个*查找几层)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2022/03/06/cpp/"/>
      <url>/2022/03/06/cpp/</url>
      
        <content type="html"><![CDATA[<ol><li><p>泛型编程强调的是独立于特定的数据类型。</p></li><li><p>C++是C语言的超集。</p></li><li><p>动态链接库 DLL(<strong>Dynamic Linker Library</strong>)：可以把DLL看做是一个仓库，它提供了一些可以直接拿来用的变量，函数或者类（但是不建议从DLL中获取变量），在历史的发展中，仓库经历了从“无库 - 静态链接库 - 动态链接库”的时代。静态链接库(.lib)和动态链接库(.dll)都是共享代码的方式。如果采用了静态链接库，则无论你愿不愿意lib中的代码指令都被直接包含进了最终生成的.exe程序中。但若是使用了动态链接库，该DLL则不会被包含进.exe程序中，当.exe程序执行的时候，再“动态”的来引用或者卸载DLL。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt; //预处理器将iostream文件的内容添加到程序中（预处理操作：在源代码被编译之前，替换或添加文本）using namespace std;//输入输出工具cin/cout//若不加上句，则如下：std::cin &gt;&gt; n;std::cout &lt;&lt; n &lt;&lt; std::endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>命名空间<strong>namespace</strong>同名时，命名空间::名称来区分。</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">//当包含多个命名空间时,用如下声明using std::cout;using std::endl;using std::cin;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>插入运算符&lt;&lt;与按位左移运算符&lt;&lt;属于运算符的重载。</p></li><li><p>控制符endl：重起一行。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;cmath&gt;cout &lt;&lt; endl;//cout &lt;&lt; "\n";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>函数声明：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void simon(int n);  //函数声明int stonetolb(int sts);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>面向对象编程(OOP)的本质是设计并扩展自己的数据类型。</p></li><li><p>变量名字母数字下划线，数字不做第一个字符，区分大小写，不能使用关键字，不限长，多个下划线保留使用。</p></li><li><p><strong>类型占字节</strong></p><ul><li>short 至少16位，</li><li>int 至少与 short 一样长，</li><li>long 至少32位，且至少与 int 一样长，</li><li>longlong 至少64位，且至少与 long 一样长。</li></ul></li><li><p>符号常量</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;climits&gt; //limits.h 最大最小值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>sizeof 是运算符，可查看类型或变量所占用的字节数，类型名需放在括号中，变量均可。</p></li><li><p>赋值，可用圆括号形式赋值。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int emus(7);int emm{7};int emn = {8};int rocs = {};//赋0unsigned short sue = 0;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第一位是0，第二位为1~7位8进制，0x为16进制。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int cheat = 42;int waist = 0x42;int inseam = 042;cout &lt;&lt; "cheat = " &lt;&lt; cheat &lt;&lt;" in dec."&lt;&lt; endl;cout &lt;&lt; "waist = " &lt;&lt; waist &lt;&lt;" in hex."&lt;&lt; endl;cout &lt;&lt; "inseam = " &lt;&lt; inseam &lt;&lt;" in oct."&lt;&lt; endl;cout &lt;&lt; hex;//十六进制打印cout &lt;&lt; "cheat = " &lt;&lt; cheat &lt;&lt;" in hex."&lt;&lt; endl;cout &lt;&lt; dec;//十进制打印cout &lt;&lt; oct;//八进制打印<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>数组赋值</strong></p><ul><li><p>只有在定义数组时才可以初始化，此后可以用下标分别给数组元素赋值，</p></li><li><p>不能将一个数组赋值给另一个数组，</p></li><li><p>初始化数组时提供的元素可以少于数组元素数目。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">long total[500] = {0};//初始化为0{}short things[] = {1, 5, 8};//数组有3个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul></li><li><p><strong>字符串以空字符结尾</strong>，空字符被写作\0，其ASCII码为0。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">char dog[5] = {'b',' ','c','e','I'};    //字符数组char cat[5] = {'a','c','f','s','\0'};   //字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>字符数组初始化为字符串，只需使用一个用引号括起的字符串即可。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">char bird[11] = "Mr. Cheeps";//隐式的包括结尾的空字符char fish[] = "Bubbles";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>字符串常量与字符常量</strong></p><table><thead><tr><th align="center"></th><th align="center">字符常量</th><th align="center">字符串常量</th></tr></thead><tbody><tr><td align="center">形式</td><td align="center">单引号引起的一个字符，’S’</td><td align="center">双引号引起的若干字符，”S”表示字符S和\0</td></tr><tr><td align="center">含义</td><td align="center">相当于一个整型值，可参加表达式运算</td><td align="center">表示字符串所在的内存地址</td></tr><tr><td align="center"></td><td align="center">字符常量可以赋值给字符变量，char b=’a’</td><td align="center">字符串常量不能赋值给字符变量</td></tr><tr><td align="center">占内存</td><td align="center">占一字节</td><td align="center">若干字节，至少一个字符结束标志</td></tr></tbody></table><p>strlen()计算字符串长度时不计入结束字符。</p></li><li><p>cin将空白字符（空格、换行、制表）作为结束符（忽略空白字符）。</p></li><li><p>istream中的类（如cin）提供了一些面向行的类成员函数：<code>getline()</code>和<code>get()</code>，每次读取一行字符串输入：<strong>getline()，丢弃换行符；get()换行符保留在输入序列中</strong>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cin.getline(name,20)/* 最多读19个字符，余下空间存储自动在结尾处添加的空字符，读取指定数目的字符或遇到换行符时停止两个参数，第一个存储输入行的数组的名称，第二个是要读取的字符数 */cin.get(name1,20);//name为字符数组cin.get(name2,20);//a problem//由于第一次调用后换行符留在输入队列中，因此第二次调用时看到的第一个字符便是换行符。因此get()认为已到达行尾。char ch;cin.get(ch);//单个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>不带任何参数的<code>cin.get()</code>调用可读取下一个字符（即使是换行符）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cin.get(name1,20);//数字和字符串交替输入时，用cin.get()消耗掉回车符cin.get();cin.get(name2,20);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>另一种是将两个类成员函数拼接起来（合并）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cin.get(name,Arsize).get();//cin.get(name,Arsize)返回一个cin对象，该对象随后用来调用get()函数。(cin &gt;&gt; year).get();/*cin &gt;&gt; year;cin.get();*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>函数重载</strong>：函数名相同，函数的参数不同。</p></li><li><p><strong>string类</strong>：提供了一种将字符串作为一种数据类型的表示方法，而不是字符数组来存储字符串。</p><ul><li><p>要使用string类，必须在程序中包含头文件string，</p></li><li><p>string类位于名称空间std中，</p></li><li><p>使用string对象的方式与使用字符数组的方式相同，</p></li><li><p>可以使用cin来将键盘输入存储到string对象中，cout来显示string对象，</p></li><li><p>数组表示法来访问存储在string对象中的字符。</p><ul><li><p>主要区别：可以将string对象声明为简单变量，而不是数组</p></li><li><p>类设计让程序能够自动处理string的大小，方便安全</p></li></ul></li><li><p>赋值：可以将string对象赋值给另一个string对象，而字符数组不可以互相赋值</p></li><li><p>拼接：可以用运算符+将两个string对象合并起来，+=将字符串附加到string对象末尾</p></li></ul></li><li><p>string的其他操作：c++新增string类之前，使用c语言库中的函数来完成C-风格字符串的操作，头文件cstring（以前为string.h）提供了这些函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">strcpy(char1, char2);//copy char2 to char1字符数组赋值strcat(char1, char2);//append contents of char2 to char1追加<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>string类I/O</code></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">char charr[20];cin.getline(charr, 20);//istream中cin类提供的成员函数int len1 = strlen(charr);//==================================================//string str;getline(cin, str);//string类的方法int len2 = str.size();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体struct：同一结构可以存储多种数据类型的数据</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct inflatable//声明结构体类型{char name[20];//std::string name;    float volume;    double price;};struct student{    char name[20];    float weight;    double height;} infor ={    "guluyu",    56.5,    178.5};//结构体对象/变量，也可创建结构体时创建结构体对象并初始化inflatable guest = {"Glorious Gloria",1.88,29.99};//C++允许在声明结构变量时省略关键字structguest.name;//通过成员名可以访问结构的成员guest.name[0];inflatable choice = guest;//结构体可以用赋值运算符初始化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>C++推荐使用局部变量，外部（全局）结构体。</p></li><li><p>结构数组：数组中的每个元素都是结构体。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">student informantion[2] =    {        {"gulu", 55, 176},        {"fish", 60, 180},    } ;cout &lt;&lt; informantion[0].name &lt;&lt; " is " &lt;&lt; informantion[0].height &lt;&lt; " cm and " &lt;&lt; informantion[0].weight &lt;&lt; " kg." &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>c++位字段允许指定占用特定位数的结构成员，用于硬件寄存器数据结构的创建。</p></li><li><p>共用体/联合体（union）可以存储不同的数据类型，但只能同时存储一种数据类型，共用内存空间，长度为其最大成员的长度。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">union one2all{    char ch;    int n;//共用体占四字节，取大};one2all num;cout &lt;&lt; "sizeof(num) = " &lt;&lt; sizeof(num) &lt;&lt; endl;num.ch = 'A';cout &lt;&lt; "num.ch = " &lt;&lt; num.ch &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>枚举：可进行连续多个的符号常量赋值，代替const 。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">enum spectrum{red, orange, yellow, green, blue};//spectrum为新类型名,内容为符号常量，依次为0~4spectrum band;band = blue;int color = blue;//枚举型可提升为int型。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>指针</strong>存储值的地址，指针名表示地址。</p></li><li><p><code>*运算符</code>被称为间接值或解除引用运算符，取值运算符。&amp;取址运算符。</p></li><li><p>指针的危险： 在对指针的内容修改之前，一定要将指针初始化为一个确定的、适当的地址。</p></li><li><p>内存分配：new运算符，返回开辟空间的首地址。指针可在运行阶段分配未命名的内存以存储值。</p></li><li><p>为一个数据对象获得并指定分配内存的通用格式：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typeName *point_name = new typeName;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>new分配的内存块通常与常规变量声明分配的内存块不同，常规都存储在栈中，而new从被称为堆或者自由存储区的内存区域分配内存。</p></li><li><p>new可能会导致内存被耗尽，可以使用delete释放内存。delete和new要配对使用，否则内存泄漏，不可以释放已经释放的内存块，不能使用delete释放声明变量所获得的内存。 </p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int *ps = new int;delete ps;//只是释放ps指向的内存，并不会删除指针ps本身int *psome = new int [10];//使用new创建动态数组delete [] psome;//释放整个数组,如果不加方扩号只释放指针指向的第一个元素，即首元素（不可以）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用<code>new</code>和<code>delete</code>时，遵守规则：</p><ul><li><p>不要使用delete来释放不是new分配的内存</p></li><li><p>不要使用delete释放同一个内存块两次</p></li><li><p>如果使用new[ ]为数组分配内存，则应该使用delete[ ]来释放</p></li><li><p>如果使用new[ ]为一个实体分配内存，则应使用delete(没有方括号)来释放内存</p></li><li><p>对空指针应用delete是安全的</p></li></ul></li><li><p>指针和动态数组基本等价：指针算术和C++内部处理数组的方式。将指针变量加1后，其增量的值等于指向的类型占用的字节数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double *p3 = new double[2];p3[0] = 0.2;p3[1] = 0.5;p3 = p3 + 1;//指针可以，数组不可以<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果cout输出指针，将打印它的地址，但如果指针类型为char*，则cout将显示指向的字符串。如果要显示字符串的地址，则必须将这种指针强制转换为另一种指针类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">char animal[20] = "bear";const char * bird = "wren";char * ps = animal;cout &lt;&lt; animal &lt;&lt; " and " &lt;&lt; bird &lt;&lt; endl;cout &lt;&lt; animal &lt;&lt; " at " &lt;&lt; (int *) animal &lt;&lt; endl;cout &lt;&lt; ps &lt;&lt; " at " &lt;&lt; (int*) ps &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>应使用strcpy()或strncpy()，而不是赋值运算符来给字符串赋给数组。</p></li><li><p>自动存储、静态存储、动态存储、线性存储</p></li><li><p>模板类<code>vector</code>类似于string类，也是一种动态数组。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;vector&gt;using namespace std;vector&lt;int&gt; vi;int n;cin &gt;&gt; n;vector&lt;double&gt; vd(n);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>模板类<code>array</code>，长度固定使用栈（静态内存分配）。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;array&gt;using namespace std;array&lt;int, 5&gt; ai;//固定array&lt;double, 4&gt; ad = {1.2, 2.4, 3.7, 5.5};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>当用字符数组接收时用<code>cin.getline(name, size);</code></p><p>当用string接收时用<code>getline(cin, str);</code></p></li><li><p>cout在显示bool之前将它们转换为int，但<code>cout.setf(ios::boolalpha)</code>函数调用设置了一个标记，该标记命令cout显示true和false，而不是1和0。</p></li><li><p><strong>递增/递减运算符和指针</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">double arr[5] = {21.1, 32.8, 23.4, 45.2, 37.4};double *pt = arr;cout &lt;&lt; *pt &lt;&lt; endl;cout &lt;&lt; "*++pt = " &lt;&lt; *++pt &lt;&lt; endl; //前缀递增/递减与取值运算符*优先级相同，优先级一样时从右到左,32.8cout &lt;&lt; "++*pt = " &lt;&lt; ++*pt &lt;&lt; endl; //33.8cout &lt;&lt; "(*pt)++ = " &lt;&lt; (*pt)++ //后缀，先括号，取出32.8(上述表达式已将指针后移)，再执行++,33.8 &lt;&lt; ", *pt = " &lt;&lt; *pt &lt;&lt; endl;//后++，34.8cout &lt;&lt; "*pt++ = " &lt;&lt; *pt++ //后缀优先级优于前缀,先取出*pt值，然后pt++是加在地址上,34.8&lt;&lt; ", *pt = " &lt;&lt; *pt &lt;&lt; endl;//23.4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>关系运算符的优先级比算数运算符的低。</p></li><li><p>C++为类型建立别名的方式有两种</p><ul><li>预处理器：不能声明一系列变量 <code>#define BYTE char</code> </li><li><code>typedef typeName aliasName</code></li></ul></li><li><p>基于范围的for循环(C++11)，对数组（或容器类，如vector和array）的每个元素执行相同的操作。</p></li><li><p>头文件iostream将cin.get(ch);的参数声明为<code>引用类型</code>，因此可以修改其参数的值。</p></li><li><p>文件尾条件——检测文件尾(EOF)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">while(cin.fail() == false)//cin.fail()为true时文件结束，判断输入是否结束,win下ctrl+Z，unix为ctrl+D//cin.clear();可以清楚EOF标记，使以后输入继续进行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>变量写在右侧，常量写在左侧更佳</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">if(3 == myNumber)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>逻辑运算符</p><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">实例</th></tr></thead><tbody><tr><td align="center">&amp;&amp;</td><td align="center">逻辑与运算符。两个操作数都 true，则条件为 true</td><td align="center">(A &amp;&amp; B) 为false</td></tr><tr><td align="center">||</td><td align="center">逻辑或运算符。两个操作数中有任意一个 true，则条件为 true，左为真则不判断右</td><td align="center">(A ||B) 为 true</td></tr><tr><td align="center">!</td><td align="center">逻辑非运算符。用来逆转操作数的逻辑状态，条件为 true 则将使其为 false</td><td align="center">!(A &amp;&amp; B) 为 true</td></tr></tbody></table></li><li><p><code>cctype</code>中的字符函数</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;cctype&gt;/* C++从C语言中继承了一个与字符相关的函数库(cctype)，它可以确定字符是否为大写或小字母、数字、标点符号等工作，这些函数包含在以下头文件中*/char ch;bool yes = isdigit(ch);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303300148244.png" alt="image-20230306114141188"></p></li><li><p>条件运算符<code>?:</code></p></li><li><p>输入内容和类型不匹配：</p><ul><li><p>n的值保持不变</p></li><li><p>不匹配的输入将被留在输入队列中</p></li><li><p>cin对象中的一个错误标记被设置</p></li><li><p>对cin方法的调用将返回false</p></li></ul> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cin.clear();//重置错误输入标记，同时也重置EOF条件while(cin.get() != '\n');//消耗输入队列中的错误内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>简单文件的输入/输出</code></p> <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;fstream&gt;   //1.头文件 ofstream      ifstream ofstream outFile;   //2.创建输出流对象//输出流对象用法同coutoutFile &lt;&lt; fixed;//小数outFile.precision(2);//两位精度outFile.setf(ios_base::showpoint);//显示小数点后0outFile.open("carinfo.txt");//3.将对象和文件关联起来,文件路径outFile &lt;&lt; "Make and model: " &lt;&lt; automobile &lt;&lt; endl;ifstream inFile;//输入流<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>综合实例</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;//使用到exit()；using namespace std;const int SIZE = 60;int main(void){    char filename[SIZE];    ifstream inFile;    ofstream ouFile;    ouFile.open("score.txt");    ouFile &lt;&lt; "350 360 380 408 292 319\n985 211 900" &lt;&lt; endl;    cout &lt;&lt; "Enter name of data file:";    cin.getline(filename, SIZE);    inFile.open(filename);    if(!inFile.is_open())//打开失败时    {        cout &lt;&lt; "Could not open the file " &lt;&lt; filename &lt;&lt; endl;        cout &lt;&lt; "Program terminating." &lt;&lt; endl;        exit(EXIT_FAILURE);    }    cout &lt;&lt; "Success open the txt file." &lt;&lt; endl;    double value, sum = 0.0;    int count = 0;    inFile &gt;&gt; value;    while(inFile.good())//读取的数据是否可用    {        ++count;        sum += value;        inFile &gt;&gt; value;    }    if(inFile.eof())//读到文件末尾        cout &lt;&lt; "End of file reached." &lt;&lt; endl;    else if(inFile.fail())        cout &lt;&lt; "Input terminated by data mismachted." &lt;&lt; endl;    else        cout &lt;&lt; "Input terminated by unknow reason." &lt;&lt; endl;    if(0 == count)        cout &lt;&lt; "No data processed." &lt;&lt; endl;    else    {        cout &lt;&lt; "Items read: " &lt;&lt; count &lt;&lt; endl;        cout &lt;&lt; "Sum: " &lt;&lt; sum &lt;&lt; endl;        cout &lt;&lt; "Average: " &lt;&lt; sum/count &lt;&lt; endl;    }    inFile.close();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>C++编程模块</p><ul><li><p>函数传递成员变量时为其拷贝值，传递数组时为原来的数组。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int cookie[ArSize] = {1, 2, 4, 8, 16, 32, 64, 128};int sum = sum_arr(cookie, ArSize);//数组名视为指针，解释为第一个元素的地址，对数组名sizeof得到整个数组的长度（字节）//为将数组类型和元素数量告诉数组处理函数int sum_arr(int arr[], int n);//数组表示法int sum_arr(int *arr, int n);//指针表示法int sum = sum_arr(cookie, cookie+8);//区间的方式int sum_arr(const int *begin, const int *end)//第一个与最后一个的后一个位置arr[i] == *(arr + i);&amp;arr[i] == arr + i;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>为使操作不修改原数组，可使用<code>const</code>。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void show_array(const double arr[], int n);const int *pt;//read-only,pt指针的指向可自定义，但不能通过这个指针修改所指的内容int *const pt;//可通过指针修改所指内容，但是不能更改指针的指向const int *const pt;//指针只能指向一个变量，并不能通过该指针修改内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>二维数组和结构体：获取结构的地址，必须使用地址运算符&amp;，与数组不同，数组名即为首地址</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int sum(int (*ar2)[4],int size);//括号不可少，size为行，4为列int sum(int ar2[][4], int size);struct polar//极坐标{    double distance;    double angle;};polar rect_to_polar(rect xypos);void show_polar(polar dapos);void rect_to_polar(const rect *xy, polar *pda);void show_polar(const polar *dapos);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>引用变量</p><p>用途：作为函数参数，结构和对象参数，不可以是常量；</p><p>必须在声明引用变量时进行初始化；</p><p>如何实参和引用参数不匹配，C++将生成临时变量，仅当参数为const引用时才可以。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int rats;int &amp; rodents = rats;//这里&amp;不是地址运算符，而是类型标识符的一部分int &amp;是指向int的引用//上述声明允许将rats和rodents互换——它们指向相同的值和内存单元，相当于同一变量的两个名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>应尽可能使用const</p><ul><li>可以避免无意中修改数据的编程错误</li><li>使函数能够处理const和非const实参，否则将只能接收非const数据</li><li>使函数能够正确生成并使用临时变量</li></ul></li><li><p>继承：使得能够将特性从一个类传递给另一个类的语言特性叫做继承。</p><ul><li>派生类继承了基类的方法</li><li>基类引用可以指向派生类的对象而无需进行强制类型转换</li></ul></li><li><p>重载：重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。</p><p>左值引用，可取地址；否则用const修饰作为常引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int a = 10;//a为左值，10为右值//int &amp;c = 10;//invalidconst int &amp;d = 10;const int &amp;c = (a+b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>C++11引入了右值引用，为了支持移动</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int &amp;&amp;x = 10;int &amp;&amp;y = (a+b);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>函数模板：使用泛型来定义函数。</p><p>如此编写，但编译后最终仍将由独立的函数定义，可将函数模板放在头文件中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">template&lt;typename T&gt;void Swap(T &amp;a, T &amp;b);template&lt;typename T&gt;void Swap(T a[], T b[], int n);//模板重载template&lt;typename T&gt;//typename = classvoid Swap(T &amp;a, T &amp;b){    T temp;    temp = a;    a = b;    b = temp;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库</title>
      <link href="/2022/02/28/c-biao-zhun-ku/"/>
      <url>/2022/02/28/c-biao-zhun-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="C-STL库"><a href="#C-STL库" class="headerlink" title="C++ STL库"></a>C++ STL库</h2><h3 id="一、数据结构角度观测C-与C"><a href="#一、数据结构角度观测C-与C" class="headerlink" title="一、数据结构角度观测C++与C"></a>一、数据结构角度观测C++与C</h3><ol><li><p>C++是C的超集，也就是说C++是可以兼容C语言的，C++在C语言的基础上增加了许多的特性和概念。</p></li><li><p>头文件引用</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">//C语言的方法：带.h的方式进行include#include&lt;stdio.h&gt;#include&lt;math.h&gt;  //C++的方法，直接引用即可#include&lt;string&gt;#include&lt;cstdio&gt;//C++引用C语言标准#include&lt;cmath&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>输入/输出：C++采用“流”的思路去进行输入输出设计，这样的做法可以大大简化我们的设计，但是这样的做法确是更慢。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">int n; //定义n为整形//C语言的输入输出（需要指定类型，如下指定为整形）scanf("%d",&amp;n);printf("%d",n);//C++语言的输入输出（不需要指定类型，会根据n进行自主的判定）cin&gt;&gt;n;cout&lt;&lt;n;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>STL：STL是Standard Template Library的简称，中文名标准模板库，惠普实验室开发的一系列软件的统称。</p></li><li><p>STL是一些“容器”与“算法”的集合，所谓的这些“容器”无非就是已经实现好了数据结构，能够让程序设计者更为方便的进行调用，“算法”则顾名思义就是已预先实现好了的算法集合。STL的目的是标准化组件，不用重新开发，可以使用现成的组件。STL现在是C++的一部分，因此不用安装额外的库文件。</p></li><li><p>在C++标准中，STL被组织为下面的13个头文件：<algorithm>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack>和<utility>。</utility></stack></set></queue></numeric></memory></map></list></vector></iterator></functional></deque></algorithm></p></li></ol><h3 id="二、标准模板库"><a href="#二、标准模板库" class="headerlink" title="二、标准模板库"></a>二、标准模板库</h3><ol><li><p>容器（Container）：是一种数据结构，list（链表）、vector（向量数组）、stack（栈）、队列（queque），以模板类的方式提供，为了访问容器中的数据，可以使用由容器类输出的迭代器。</p></li><li><p>迭代器（Iterator）：是一种特殊的指针，提供了访问容器中的对象的方法，在程序设计中，扮演了容器和算法之间的胶合剂，利用迭代器可以快速而安全的对容器内容进行操作，或是进行算法模板的使用。</p></li><li><p>算法（Algorithm）：是一类常用的算法模板，既可以对容器进行操作，同时其开放性也让算法类本身可以针对数组或者是自定义结构体等结构进行直接的操作。</p></li><li><p>仿函数（Function object），（又称为函数对象，function object），是一种行为类似函数，重载了()操作符的结构体与类。</p></li><li><p>迭代适配器（Iterator Adaptor），一种用来修饰容器或者仿函数的接口，它使得得带适配器使算法能够以逆向模式，安插模式进行工作，甚至还可以与流配合，它对容器起到非常大的辅助作用，同时他还将迭代器进行了更高级别的抽象。</p></li><li><p>空间配制器（allocator），是负责空间的配置与管理，重点就是对容器的空间申请和空间释放进行管理，理解为C的malloc和free函数，C++的new和delete关键字。</p></li></ol><h3 id="三、Vector容器"><a href="#三、Vector容器" class="headerlink" title="三、Vector容器"></a>三、Vector容器</h3><ol><li><p>Vector就是一个动态创建空间，且预先加载了常用的数组操作的数组。</p></li><li><p>格式为：vector<data_types> name;</data_types></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;vector&gt;//不带参数的构造函数初始化vector&lt;int&gt; v1;//创建一个空的向量v1,size = 0//带参数的构造函数初始化vector&lt;double&gt; v2(10);//其已开辟10个元素的空间，double v2[10];vector&lt;int&gt; v3(10,5); //其已开辟10个元素的空间并全部赋值为5//通过insert初始化vector&lt;int&gt; v4(v3.begin(),v3.end());//v4,其内容为向量v3的内容//insert初始化方式将同类型的迭代器对应的始末区间（左闭右开区间）内的值插入到vector中vector&lt;int&gt; a(6,6);vecot&lt;int&gt; b;//将a[0]~a[2]插入到b中，b.size()由0变为3b.insert(b.begin(), a.begin(), a.begin() + 3);//insert也可通过数组地址区间实现插入int a[6] = {6,6,6,6,6,6};vector&lt;int&gt; b;//将a的所有元素插入到b中，同样是左闭右开区间b.insert(b.begin(), a, a+6);//insert还可以插入m个值为n的元素//在b开始位置处插入6个7b.insert(b.begin(), 6, 7);//通过同类型的vector初始化vector&lt;int&gt; v5(v4);//创建一个向量v5，其包含了v4的全部内容int a[5] = {1,2,3,4,5};//通过数组a的地址初始化，注意地址是从0到5（左闭右开区间）vector&lt;int&gt; b(a, a+5);//通过copy函数赋值vector&lt;int&gt; a(5,1);int a1[5] = {2,2,2,2,2};vector&lt;int&gt; b(10);/*将a中元素全部拷贝到b开始的位置中,注意拷贝的区间为a.begin() ~ a.end()的左闭右开的区间*/copy(a.begin(), a.end(), b.begin());//拷贝区间也可以是数组地址构成的区间copy(a1, a1+5, b.begin() + 5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>迭代器：一种安全的访问控制器，它本身是一种指针，用于直接的元素访问。其遍历访问的大致思路是，创建容器的迭代器，让迭代器指向第一个元素，逐步向后移动并最终指向最后一个元素结束。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; v;       //创建一个向量vsvector&lt;int&gt;::iterator it;   //C98标准for(it=v.begin();it!=v.end();it++){    cout&lt;&lt;*it&lt;&lt;' ';}// for(int i=0;i&lt;v.size();i++){        cout&lt;&lt;v[i]&lt;&lt;' ';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>常用接口</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; v;//在向量的末尾添加一个新元素val，并自动让容器大小增大一个v.push_back(10);  //插入一个数据10//移除向量尾的最后一个元素，并且将容器大小减小一个v.pop_back();//插入元素到指定位置，通过在元素之前在指定位置插入新元素来扩展向量，从而有效地增加容器大小所插入的元素数量 v.insert(v.begin(),10);     //在向量最前端插入数据10 v.insert(v.begin(),5,20);   //在向量最前端插入5个数据20 vector&lt;int&gt; k(2,50);   //创建一个新的向量k,其拥有2个元素内容均为50 v.insert(v.begin(),k.begin(),k.end());  //在向量v最前端插入向量K的全部内容//删除一个元素，或者是一段区间的元素，将会自动缩减空间使用v.erase(v.begin());     //删除第一个元素v.erase(v.begin(),v.begin()+4); //删除从第一个开始后4个元素（包括第一个）//将向量中所有元素清空v.clear();//清空向量//返回向量中的数据元素个数cout&lt;&lt;v.size()&lt;&lt;endl;   //输出5//返回向量最大已开辟的空间大小vector&lt;int&gt; v(3,10);    //创建默认有3个值为10的元素的向量vv.insert(v.begin(),10,20);   //在向量最前端插入10个值为20的数据v.erase(v.begin(),v.begin()+4); //删除从第一个开始后4个元素（包括第一个）cout&lt;&lt;v.capacity()&lt;&lt;endl;   //输出13//返回计算机支持开辟vector的最大空间值，一般来说和计算机内存和CPU相关，是一个极大的数据，而且不同计算机中可能有不同的值vector&lt;int&gt; v(5,10);    //创建默认有5个值为10的元素的向量vcout&lt;&lt;v.max_size()&lt;&lt;endl;   //输出4611686018427387903<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="四、List容器"><a href="#四、List容器" class="headerlink" title="四、List容器"></a>四、List容器</h3><ol><li><p>初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;list&gt;list&lt;int&gt; l1;           //创建一个空链表list&lt;int&gt; l2(10);       //创建一个链表其有10个空元素list&lt;int&gt; l3(5,20);     //创建一个链表其有5个元素内容为20list&lt;int&gt; l4(l3.begin(),l3.end());  //创建一个链表其内容为l3的内容list&lt;int&gt; l5(l4);               //创建一个链表其内容为l4的内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>迭代器</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">list&lt;int&gt; li;for(list&lt;int&gt;::iterator it=li.begin();it!=li.end();it++){    cout&lt;&lt;*it&lt;&lt;' ';}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>常用接口</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">list&lt;int&gt; li;//判断是否为空empty()//返回一个bool类型的值，只存在真和假，当链表为空时为真，不为空时为假if(li.empty()){     //当链表为空的时候执行    cout&lt;&lt;"is empty()"&lt;&lt;endl;}else{    cout&lt;&lt;"not empty()"&lt;&lt;endl;}//获取大小size()，返回链表元素的个数cout&lt;&lt;li.size()&lt;&lt;endl;//链表前插入push_front() &amp;&amp;链表前删除 pop_front()li.push_front(10);li.pop_front();//链表后插入push_back() &amp;&amp;链表后删除 pop_back()li.push_back(10);li.pop_back();//插入元素到指定位置，通过在元素之前在指定位置插入新元素来扩展向量li.insert(li.begin(),10);     //在链表最前端插入数据10li.insert(li.begin(),5,20);   //在链表最前端插入5个数据内容为20list&lt;int&gt; k(2,50);   //创建一个新的链表k,其拥有2个元素内容均为50li.insert(li.begin(),k.begin(),k.end());  //在链表li最前端插入链表上K的全部内容//删除一个元素，或者是一段区间的元素，将会自动缩减空间使用li.erase(li.begin());     //删除第一个元素li.erase(li.begin(),li.begin()+4); //删除前4个元素//让整个链表变成升序状态，或者变成自定义的排序状态li.sort();//升序li.sort(cmp);//降序//相对于自定义的降序方法li.reverse();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="五、stack栈容器"><a href="#五、stack栈容器" class="headerlink" title="五、stack栈容器"></a>五、stack栈容器</h3><ol><li><p>初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;stack&gt;stack&lt;int&gt; s;//创建一个栈stack&lt;int&gt; v(s);//创建一个栈为s的全部内容vector&lt;int&gt; v(3,100);           stack&lt;int,vector&lt;int&gt; &gt; s(v);  //注意，&gt; &gt;符号之间需要有一个空格隔开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>常用接口</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">stack&lt;int&gt; s;cout&lt;&lt;s.size()&lt;&lt;endl;   //直接返回栈中元素的个数cout&lt;&lt;s.top()&lt;&lt;endl;     //直接返回输出即可s.top()+=100;            //也可以直接对栈定元素进行修改操作s.push(5);//5入栈s.pop();while(!s.empty())//判空{    cout&lt;&lt;s.top()&lt;&lt;endl;    s.pop();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="六、Queue容器"><a href="#六、Queue容器" class="headerlink" title="六、Queue容器"></a>六、Queue容器</h3><ol><li><p>初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;queue&gt;queue&lt;int&gt; q;//创建一个空的没有数据的队列qqueue&lt;int&gt; v(q);//创建一个队列v其元素为q的全部内容vector&lt;int&gt; v(3, 100);queue&lt;int, vector&lt;int&gt; &gt; s(v);//内容就是vector数组的全部内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>常用接口</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">queue&lt;int&gt; q;cout &lt;&lt; q.size() &lt;&lt; endl;q.push(100);//100入队q.pop();//出队//访问对头元素，可以返回其数值，也可以进行相应的操作q.front() += 500; //对队头元素进行修改cout &lt;&lt; q.front() &lt;&lt; endl;//直接输出内容//访问队尾元素，较为少用q.back()+=500;     //对队尾元素进行修改cout&lt;&lt; q.back() &lt;&lt;endl;while(q.empty())//判空{    cout&lt;&lt;q.front()&lt;&lt;endl;    q.pop();}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="七、优先队列（Priority-queue）"><a href="#七、优先队列（Priority-queue）" class="headerlink" title="七、优先队列（Priority_queue）"></a>七、优先队列（Priority_queue）</h3><ol><li><p>优先队列的底层是以散列的状态（非线性）表现的，他与标准的队列有如下的区别，标准的队列遵从严格的先进先出，优先队列并不遵从标准的先进先出，而是对每一个数据赋予一个权值，根据当前队列权值的状态进行排序，使得权值最大（或最小）的永远排在队列的最前面。</p></li><li><p>初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;queue&gt;priority_queue&lt;T, Container, Compare&gt;priority_queue&lt;T&gt;//直接输入元素则使用默认容器和比较函数a) T就是Type为数据类型b) Container是容器类型，（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector）c) Compare是比较方法，类似于sort第三个参数那样的比较方式，对于自定义类型，需要我们手动进行比较运算符的重载。与sort直接Bool一个函数来进行比较的简单方法不同，Compare需要使用结构体的运算符重载完成，直接bool cmp(int a,int b){  return a&gt;b; } 这么写是无法通过编译的。    struct cmp{ //这个比较要用结构体表示    bool operator()(int &amp;a, int &amp;b) const    {        return a &gt; b;    }};  priority_queue&lt;int,vector&lt;int&gt;,cmp&gt; q;    //使用自定义比较方法priority_queue&lt;int&gt; pq;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="八、Set容器"><a href="#八、Set容器" class="headerlink" title="八、Set容器"></a>八、Set容器</h3><ol><li><p>Set（集合）属于关联式容器，依据特定的排序准则，自动为其元素排序。Set集合的底层使用一颗红黑树，其属于一种非线性的数据结构，每一次插入数据都会自动进行排序。</p></li><li><p>Set的性质有：数据自动进行排序且数据唯一，是一种集合元素，允许进行数学上的集合相关的操作。</p></li><li><p>初始化</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;set&gt;template &lt; class T,                                   class Compare = less&lt;T&gt;,                   class Alloc = allocator&lt;T&gt;                 &gt; class set;//基本上就是三个参数，第一个是值，第二个比较器，用于比较内容，默认为less&lt;Key&gt;即降序，第三个是内存配置器，负责内存的分配和销毁。set&lt;int&gt; s;       //直接指定值的类型创建，其他为默认方法for (set&lt;int&gt;::iterator it=s.begin(); it!=s.end(); ++it)        cout &lt;&lt; *it &lt;&lt; ' ';//迭代器 for (auto it=s.cbegin(); it!=s.cend(); ++it)        cout &lt;&lt; *it &lt;&lt; ' ';cout &lt;&lt; s.size() &lt;&lt; endl;   //直接返回元素个数s.insert(i);//插入一个元素，插入元素的类型必须与创建的容器类型一致//删除一个元素，或者是一段区间的元素，将会自动缩减空间使用。s.erase(s.begin());  //使用迭代器的方法删除第一个元素s.erase(s.begin(),s.end());     //删除一段内容，这里是全部删除s.clear();//这里只是清空元素，其所占用的最大内存空间还是不会改变的。//查找元素find()cout &lt;&lt; *s.find(4) &lt;&lt; endl;s.erase(s.find(4));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python（三）</title>
      <link href="/2022/01/19/python3/"/>
      <url>/2022/01/19/python3/</url>
      
        <content type="html"><![CDATA[<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="一、切片（Slice）"><a href="#一、切片（Slice）" class="headerlink" title="一、切片（Slice）"></a>一、切片（Slice）</h3><ol><li><p>取一个list或tuple的部分元素的操作。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 法一：若截断N个元素，该方法不好用[L[0], L[1]]# 法二：循环r = []n = 4for i in range(n): # 0~n-1    r.append(L[i])print(r)# 法三：切片操作符print(L[0:3]) # 0-2# 如果第一个索引是0，可以省略L[:3]L[1:3] # 从1开始，取2个元素# 同样支持倒数切片L[-2:] # 倒数第2个到最后L[-2:-1] # -2到-1，不含-1A = list(range(100)) #0-99的列表A[-10:] #后10个数A[:10] #前10个数A[10:20] #前11-20个数 10-19A[:10:2] # 前10个数，每两个取一个A[::5] #所有数，每5个取一个A[:] #只写[:]就可以原样复制一个list<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">(0,1,2,3,4,5)[:3] # (0, 1, 2)(0,1,2,3,4,5)[2:] # (2, 3, 4, 5)(0,1,2,3,4,5)[::2] # (0, 2, 4)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>字符串<code>'xxx'</code>也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">'ABCDEFG'[:3] # 'ABC''ABCDEFG'[1::2] # 'BDF'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="二、迭代"><a href="#二、迭代" class="headerlink" title="二、迭代"></a>二、迭代</h3><ol><li><p>Python中用<code>for...in...</code>来完成迭代，可以通过<code>for</code>循环来遍历<code>list</code>或<code>tuple</code>。</p></li><li><p>Python的for循环抽象程度要高于C的for循环，因为Python的for循环不仅可以用在list或tuple上，还可以作用在其他可迭代对象上。</p></li><li><p>只要是可迭代对象，无论有无下标，都可以迭代，比如<code>dict</code>就可以迭代。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d = {'a':1, 'b':2, 'c':3}for key in d: # dict默认迭代key    print(key)for value in d.values(): # dict用values()可迭代访问value    print(value)for k,v in d.items(): # dict同时迭代key和value    print(k,'=',v)for ch in 'ABCDEFG' :    print(ch)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如何判断一个对象是否是可迭代对象？可以通过<code>collections.abc</code>模块的<code>Iterable</code>类型判断。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from collections.abc import Iterableisinstance('abc', Iterable) #str是否可迭代 Trueisinstance([1,2,3], Iterable) # list是否可迭代 Trueisinstance(123, Iterable) # 整数不可迭代 False<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对list实现下标循环，使用Python内置的<code>enumerate</code>函数，把一个list变成索引-元素对，就可以在for循环中同时迭代索引和元素本身</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i, value in enumerate(['A', 'B', 'C']):    print(i, value)# Python中可以在for循环引用多个变量for x, y in [(1, 1), (2, 4), (3, 9)]:    print(x, y)for x, y, z in [(1, 2, 3), (3, 4, 6), (5, 6, 9)]:    print(x, y, z)    <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>迭代查找一个list中的最大值和最小值，并返回一个tuple</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">li = [1,3,5,9,4,0,6]def fine_min_max(n):    if len(n) == 0:        return None, None    else:        min = max = li[0]        for i in n :            if i &gt; max:                max = i            if i &lt; min:                min = i        return (min, max)print(fine_min_max(li))def find2(L):    L1 = L[:]    L1 = sorted(L1)    max = L1[-1]    min = L1[0]    return(max, min)print(find2(li))     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="三、列表生成式"><a href="#三、列表生成式" class="headerlink" title="三、列表生成式"></a>三、列表生成式</h3><ol><li><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list(range(1, 11)) # 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]L = []for x in range(1,11): # 生成[1x1, 2x2, 3x3, ..., 10x10]    L.append(x*x)# 循环繁琐，用列表生成器[x * x for x in range(1,11)][x * x for x in range(1,11) if x % 2 == 0] # 筛选出偶数# 两层循环全排列[m + n for m in 'ABC' for n in 'XYZ'][j+k+l for j in '12345' for k in 'NUSQX' for l in '@#$%&amp;']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>运用列表生成式，列出当前目录下的所有文件和目录名。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">import os # 导入os模块[d for d in os.listdir('.')] # os.listdir可以列出文件和目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>列表生成器使用两个变量生成list。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d = {'x':'A','y':'B','z':'C'}[k+'=' + v for k, v in d.items()]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>把一个list中所有的字符串变成小写。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">str.lower()str.upper()L = ['HELLO', 'World', 'Apple', 'GOOD'][s.lower() for s in L][s.upper() for s in L]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>列表生成式中的<code>if...else...</code>使用。for后面的if是一个筛选条件，不能带else；for前面的部分是一个表达式，它必须根据x计算出一个结果，要带上else。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">[x for x in range(1, 11) if x % 2 == 0] # [2, 4, 6, 8, 10][x if x % 2 == 0 else -x for x in range(1, 11)] #  [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="四、生成器"><a href="#四、生成器" class="headerlink" title="四、生成器"></a>四、生成器</h3><ol><li><p><strong>一边循环一边计算的机制，称为生成器：generator。</strong>通过列表生成式，直接创建一个列表，但是受到内存限制，列表容量肯定是有限的。而且如果在一个占用内存很大的列表中含有很多元素，而只需访问前几个元素，那么绝大多数元素占用的空间就被浪费了。如果列表能够按照某种算法推算出后面的元素，就可以不必创建完整的list从而节省大量空间。</p></li><li><p>创建生成器的方法</p><ul><li><p>把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator。可以通过next()函数获得generator的下一个返回值，generator保存的是算法，每次调用<code>next(g)</code>，就计算出<code>g</code>的下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出<code>StopIteration</code>的错误。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">g = (x * x for x in range(10))next(g)next(g)# 上面不断调用next(g)，繁琐# 正解：用for循环for n in g:    print(n)def fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        print(b)        a, b = b, a+b        n = n + 1    return 'done'fib(6)# 上面的函数和generator仅一步之遥。要把fib函数变成generator函数，只需要把print(b)改为yield b就可以了def fib2(max):    n, a, b = 0, 0, 1    while n &lt; max:        yield b        a, b = b, a + b        n = n + 1    return 'done'f = fib2(6)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在循环中不断调用<code>yield</code>就会不断中断，要给循环设置一个条件来退出循环；同样的把函数改成generator函数后，不用next()获取返回子而是直接用for循环迭代</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">for n in fib2(6):    print(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>但是用for循环调用generator时，发现拿不到generator的<code>return</code>语句的返回值。如果想要拿到返回值，必须捕获<code>StopIteration</code>错误，返回值包含在<code>StopIteration</code>的<code>value</code>中。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">g = fib2(6)while True:    try:        x = next(g)        print('g:', x)    except StopIteration as e :        print('Generator return value:', e.value)        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>如果一个函数定义中包含<code>yield</code>关键字，那么这个函数就不再是一个普通函数，而是一个generator函数，调用一个generator函数将返回一个generator。generator函数和普通函数的执行流程不一样。普通函数是顺序执行，遇到<code>return</code>语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def odd():    print('step 1')    yield 1    print('step 2')    yield 2    print('step 3')    yield 3o = odd()next(o) # step 1next(o) # step 2next(o) # step 3next(odd()) # step 1next(odd()) # step 1next(odd()) # step 1# 原因在于odd()会创建一个新的generator对象，上述代码实际上创建了3个完全独立的generator，对3个generator分别调用next()当然每个都会返回第一个值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>调用该generator函数时，首先要生成一个generator对象，然后用<code>next()</code>函数不断获得下一个返回值。</p></li></ul></li><li><p>杨辉三角形</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def triangles():    L = [1]    yield L    while True:        L = [v+w for v,w in zip([0]+L,L+[0])]        yield L#打印三角for i,row in enumerate(triangles()):    print(row)    if i&gt;=10:        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="五、迭代器"><a href="#五、迭代器" class="headerlink" title="五、迭代器"></a>五、迭代器</h3><ol><li><p>可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>；可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p></li><li><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">from collections.abc import Iterableisinstance([], Iterable)from collections.abc import Iteratorisinstance([], Iterator)isinstance({}, Iterator)isinstance('abc', Iterator)isinstance(iter([]), Iterator)isinstance(iter('abc'), Iterator)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python（二）</title>
      <link href="/2022/01/16/python2/"/>
      <url>/2022/01/16/python2/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="一、函数"><a href="#一、函数" class="headerlink" title="一、函数"></a>一、函数</h3><ol><li><p>抽象：抽象使我们能以一种区分所谓的逻辑对象和物质对象的方式来看待问题及其解决方案。如，求和函数。</p></li><li><p>Python中内置了很多函数，可以在交互式命令行通过<code>help(function_name)</code>查看函数function_name的帮助信息。</p></li><li><p>数据类型转换：内置数据类型转换函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">int('123') # 123int(12.34) # 12float('12.34') # 12.34str(1.23) # '1.23'str(100) # '100'bool(1) # Truehex(10) # '0xa' 字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = absa(-10) # 10<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="二、函数定义"><a href="#二、函数定义" class="headerlink" title="二、函数定义"></a>二、函数定义</h3><ol><li><p><code>def</code>语句，依次写出函数名、括号、括号中的参数和冒号，然后在缩进块中编写函数体，函数的返回值用return语句返回。</p></li><li><p>函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。如果没有return语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<code>return None</code>可以简写为<code>return</code>。</p></li><li><p>把定义的函数保存在<code>file.py</code>文件，可以在该文件的当前目录下启动Python解释器，用<code>from file import function_name</code>来导入<code>function_name()</code></p></li><li><p><strong>空函数</strong>，用<code>pass</code>语句，可以用来作为占位符</p></li><li><p><strong>参数检查</strong>，自定义的函数使用内置函数<code>isinstance()</code>实现</p></li><li><p><strong>返回多个值</strong>，实则返回的是一个tuple，但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def my_abs(x):    if not isinstance(x, (int,float)):        raise TypeError('bad operand type')    if x &gt;= 0:        return x    else:        return -xprint(my_abs(-10))def nop():    passimport mathdef move(x,y,step,angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx,nyx, y = move(100, 100, 60, math.pi / 6)print(x, y)def quadratic(a, b, c):    x1 = (-b + math.sqrt(b**2-(4*a*c))) / (2 * a)    x2 = (-b - math.sqrt(b**2-(4*a*c))) / (2 * a)    return x1, x2q = quadratic(2, 3, 1)print(q)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>位置参数</strong>，函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>。</p></li><li><p><strong>默认参数</strong>，如def power(x, n=2): n为默认参数。</p></li><li><p>默认参数可以简化函数的调用。设置默认参数时，有几点要注意：</p><ul><li>必选参数在前，默认参数在后，否则Python的解释器会报错；</li><li>如何设置默认参数，当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li><li>使用默认参数最大的好处是能降低调用函数的难度。</li></ul><pre class="line-numbers language-python" data-language="python"><code class="language-python">def enroll(name, gender, age, city='YZU'):    print('name:',name)    print('gender:',gender)    print('age:',age)    print('city:',city)enroll('nusqx', 'male', 22)enroll('yx', 'female', 22, city='JNU')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有多个默认参数时，调用的时候，既可以按顺序提供默认参数，也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。</p></li><li><p>定义默认参数要牢记一点：默认参数必须指向不变对象！</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def add_end(L = []):    L.append('END')    return L#默认参数是[]，但是函数似乎每次都“记住了”上次添加了`'END'`后的list。add_end([1,2,3]) # [1, 2, 3, 'END']add_end() # ['END']add_end() # ['END', 'END']#要修改上面的例子，我们可以用None这个不变对象来实现：def add_end2(L=None):    if L is None:        L = []    L.append('END')    return Ladd_end2([1,2,3]) # [1, 2, 3, 'END']add_end2() # ['END']add_end2() # ['END']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>可变参数</strong>，传入的参数个数是可变的。可变参数允许传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。Python允许在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def calc1(numbers):    sum = 0    for n in numbers:        sum = sum + n * n    return sumcalc1([1,2,3]) # 14 calc1((1,2,3)) # 14# 把函数的参数改为可变参数：def calc2(*number):    sum = 0    for n in number:        sum = sum + n * n    return sumcalc2(1,2,3) # 14# 如果已经有一个list或tuple，调用可变参数如下：nums = [1, 2, 3]calc2(nums[0],nums[1],nums[2]) # 14clac2(*nums) # 14<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>*nums</code>表示把<code>nums</code>这个list的所有元素作为可变参数传进去。</p></li><li><p><strong>关键字参数</strong>，关键字参数允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>，如果调用者愿意提供更多的参数，也能收到。试想正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def person(name, age, **kw):    print('name:', name, 'age:', age, 'other:', kw)person('Bob',30)person('Michael', 18, city='YZ')# 函数person除了必选参数name和age外，还接受关键字参数kw# 可以只传入必选参数，也可以传入任意个数的关键字参数extra = {'city': 'Beijing', 'job': 'Engineer'}person('Jack', 24, city=extra['city'], job=extra['job'])person('Jack', 24, **extra)# **extra表示把extra这个dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>命名关键字参数</strong>，对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过<code>kw</code>检查。调用者仍可以传入不受限制的关键字参数，如果要限制关键字参数的名字，就可以用<strong>命名关键字参数</strong>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def person(name, age, **kw):    if 'city' in kw:        # 有city参数        pass    if 'job' in kw:        # 有job参数        pass    print('name:', name, 'age:', age, 'other:', kw)# 调用者仍可以传入不受限制的关键字参数person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)    # 如果要限制关键字参数的名字，就可以用命名关键字参数，只接收city和job作为关键字参数def person(name, age, *, city, job):    print(name, age, city, job)person('Jack', 24, city='Beijing', job='Engineer')#命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。#如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了def person3(name, age, *args, city, job):    print(name, age, args, city, job)#命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错#命名关键字参数可以有缺省值，从而简化调用def person4(name, age, *, city='Beijing', job):    print(name, age, city, job)#由于命名关键字参数city具有默认值，调用时，可不传入city参数person('Jack', 24, job='Engineer')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个<code>*</code>作为特殊分隔符。如果缺少<code>*</code>，Python解释器将无法识别位置参数和命名关键字参数。</p></li><li><p><strong>参数组合</strong>，在Python中定义函数，可以用<strong>必选参数、默认参数、可变参数、关键字参数和命名关键字参数</strong>，这5种参数都可以组合使用。<strong>参数定义的顺序</strong>必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def f1(a, b, c=0, *args, **kw):    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw):    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)f1(1,2,3,'a','b') #a= 1 b= 2 c= 3 args= ('a', 'b') kw= {}f1(1,2,3,'a','b','c',x = 99,y=100) # a= 1 b= 2 c= 3 args= ('a', 'b', 'c') kw= {'x': 99, 'y': 100}f2(1,2,d=99,ex=5,ee=None) # a = 1 b = 2 c = 0 d = 99 kw = {'ex': 5, 'ee': None}# 通过一个tuple和dict，你也可以调用上述函数args = (1, 2, 3, 4)kw = {'d': 99, 'x': '#'}f1(*args, **kw)# a = 1 b = 2 c = 3 args = (4,) kw = {'d': 99, 'x': '#'}args = (1, 2, 3)kw = {'d': 88, 'x': '#'}f2(*args, **kw) # a = 1 b = 2 c = 3 d = 88 kw = {'x': '#'}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>递归函数：使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。</p></li><li><p>针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">def fact(n): # 阶乘    if n == 1:        return 1    else:        return n * fact(n-1)fact(5)def move(n, a, b, c): # 汉诺塔，n是第一个柱子上圆盘数    if n == 1:        print('move', a, '--&gt;', c)    else:        move(n-1, a, c, b)        move(1, a, b, c)        move(n-1, b, a, c)move(3, 'A', 'B', 'C')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><blockquote><p>函数参数小结</p><p>Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。</p><p>默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！</p><p>要注意定义可变参数和关键字参数的语法：</p><p><code>*args</code>是可变参数，args接收的是一个tuple；</p><p><code>**kw</code>是关键字参数，kw接收的是一个dict。</p><p>以及调用函数时如何传入可变参数和关键字参数的语法：</p><p>可变参数既可以直接传入：<code>func(1, 2, 3)</code>，又可以先组装list或tuple，再通过<code>*args</code>传入：<code>func(*(1, 2, 3))</code>；</p><p>关键字参数既可以直接传入：<code>func(a=1, b=2)</code>，又可以先组装dict，再通过<code>**kw</code>传入：<code>func(**{'a': 1, 'b': 2})</code>。</p><p>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。</p><p>命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。</p><p>定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符<code>*</code>，否则定义的将是位置参数。</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python（一）</title>
      <link href="/2022/01/12/python/"/>
      <url>/2022/01/12/python/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><h3 id="一、python的应用"><a href="#一、python的应用" class="headerlink" title="一、python的应用"></a>一、python的应用</h3><ol><li>网络应用：网站、后台服务</li><li>工具：脚本</li><li>包装其他语言开发的工具</li></ol><h3 id="二、优缺点"><a href="#二、优缺点" class="headerlink" title="二、优缺点"></a>二、优缺点</h3><ol><li>提供了完善的基础代码库，覆盖网络、文件、GUI、数据库、文本等大量内容，被形象的称为”内置电池“</li><li>大量第三方库</li><li>优雅、明确、简单</li><li>语法简单，使用缩进式</li><li>运行速度慢（解释性语言）</li><li>代码不能加密（大家都那么忙，哪有闲工夫破解你的烂代码）</li></ol><h3 id="三、简介"><a href="#三、简介" class="headerlink" title="三、简介"></a>三、简介</h3><ol><li>python以<code>#</code>开头的语句是注释</li><li>采取缩进式，惯例为四个空格的缩进</li><li>冒号<code>:</code>结尾时，缩进的语句是为代码块</li><li>大小写敏感</li></ol><h2 id="二、Python基础"><a href="#二、Python基础" class="headerlink" title="二、Python基础"></a>二、Python基础</h2><h3 id="一、输入输出"><a href="#一、输入输出" class="headerlink" title="一、输入输出"></a>一、输入输出</h3><ol><li><p>输出print()</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print('hello,world')print('My name is','nusqx')# print()会依次打印每个字符串，遇到逗号','会输出一个空格 My name is nusqxprint('10+20=',10+20) # 10+20=30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>输入input()，返回的数据类型是<code>str</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">name = input() # nusqxprint(name) # nusqx# 输入时加提示信息name = input('please enter your name: ')print('hello,',name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、数据类型和变量"><a href="#二、数据类型和变量" class="headerlink" title="二、数据类型和变量"></a>二、数据类型和变量</h3><ol><li><p>在python中能直接处理的数据类型</p><ul><li><p><strong>整数</strong>，与数学中的写法一样</p><p><code>0x</code>前缀和0-9，a-f表示十六进制</p><p>对于很大的数，数字中间可以用<code>_</code>分割，100_000_000</p></li><li><p><strong>浮点数</strong>，小数，科学计数法</p><p>1.23*10-5即1.23e-5</p></li><li><p><strong>字符串</strong>，用<code>''</code>或<code>""</code>表示</p><p>字符串内部包含引号字符，用转义字符<code>\</code>表示，如<code>'I\'m OK'</code></p><p>转义字符可以转义很多字符，如\n表示换行符，\t表示制表符，<code>\\</code>表示<code>\</code></p><p>如果字符串包含很多字符需要转义，可以用<code>r''</code>表示<code>''</code>内部的字符串默认不转义</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print("I'm NUSQX")print(r'\\\t\\\\')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果字符串内部有很多换行，用<code>\n</code>写在一行不好阅读，可以用’’’…’’’的格式</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">print('''line1... line2... line3''') #上面是在交互式命令行内输入，在输入多行内容时，提示符由&gt;&gt;&gt;变为...print('''line1line2line3''')line1line2line3#接着上一行输入，注意...是提示符，不是代码的一部分<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>布尔值</strong>，True和False</p><p>布尔值可以用<code>and</code>、<code>or</code>、<code>not</code>运算（与、或、非）</p></li><li><p>空值<code>None</code></p></li><li><p>Python还提供了列表、字典等多种数据类型</p></li></ul></li><li><p>变量，变量名必须是大小写英文字母、数字、下划线的组合，数字不能开头</p></li><li><p>Python是动态语言，变量本身类型不固定的语言称之为<em>动态语言</em>，与之对应的是<em>静态语言</em>。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言。</p></li><li><p>常量通常用全部大写的变量名表示常量</p></li><li><p>python中有两种除法，</p><ul><li>一种<code>/</code>，计算结果是浮点数，即使是两个整数恰好整除，结果仍是浮点数</li><li>另一种<code>//</code>地板除，只取结果的整数部分</li></ul></li><li><p>余数运算<code>%</code></p></li><li><p>python中<code>type()</code>函数可以查看类型</p></li></ol><h3 id="三、字符串和编码"><a href="#三、字符串和编码" class="headerlink" title="三、字符串和编码"></a>三、字符串和编码</h3><ol><li><p>Unicode把所有语言都统一到一套编码里，就不会再有乱码问题了。</p></li><li><p>ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p></li><li><p>如果统一成Unicode编码，乱码问题从此消失了。但是，如果写的文本基本上全部是英文，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p></li><li><p>把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码，UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。</p></li><li><p>计算机系统通用的字符编码工作方式：在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202304141434628.png" alt="rw-file-utf-8"></p></li><li><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202304141436470.png" alt="web-utf-8"></p></li><li><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">ord('A') # 65ord('a') # 97chr(66) # 'B'chr(0x4e2d) # '中''\u4e2d' # '中'chr(25991) '文'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>计算字符串长度<code>len()</code>函数</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = 'nusqx'len(a)len(SQX)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>格式化输出<code>%</code></p><p>常见的占位符有：有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应。如果只有一个<code>%?</code>，括号可以省略。</p><table><thead><tr><th align="center">占位符</th><th align="center">替换内容</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">整数</td></tr><tr><td align="center">%f</td><td align="center">浮点数</td></tr><tr><td align="center">%s</td><td align="center">字符串</td></tr><tr><td align="center">%x</td><td align="center">十六进制整数</td></tr></tbody></table><p>其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数。</p></li><li><p>字符串里面的<code>%</code>是一个普通字符，这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code></p></li><li><p><code>format()</code>方法格式化字符串，用传入的参数依次替换字符串内的占位符<code>{0}</code>、<code>{1}</code>…</p></li><li><p><code>f-string</code>使用以<code>f</code>开头的字符串，称之为<code>f-string</code>，它和普通字符串不同之处在于，字符串如果包含<code>{xxx}</code>，就会以对应的变量替换</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">'hello, %s' % 'nusqx''Hi, %s, you have %d apples.' % ('nusqx', 6)print('%2d-%02d' % (3,1)) # 3.1000'%.4f'%3.1415926 # 3.1416'growth rate: %d %%' % 7 # 7 %'hello,{0},中奖{1}百万'.format('nusqx',500)r = 2.5s = 3.14 * r ** 2print(f'The area of a circle with radius {r} is {s:.2f}')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="四、使用列表list和元组tuple"><a href="#四、使用列表list和元组tuple" class="headerlink" title="四、使用列表list和元组tuple"></a>四、使用列表list和元组tuple</h3><ol><li><p>python内置列表：<code>list</code>，一种有序的集合，可以随时添加和删除其中元素</p></li><li><p><code>len()</code>函数可以获取list元素的个数</p></li><li><p>用索引访问list中的每一个位置的元素，0开始，不可越界；如果访问最后一个，也可用-1，以此类推</p></li><li><p>往list中追加元素到末尾<code>append()</code></p></li><li><p>把元素插入到指定位置<code>insert()</code></p></li><li><p>删除list末尾元素<code>pop()</code></p></li><li><p>删除指定位置元素<code>pop(i)</code></p></li><li><p>替换某个元素，可以直接赋值给对应的索引位置</p></li><li><p>list中元素数据类型可以不同</p></li><li><p>list元素可以是另一个list，访问list中list，可以看作二维数组，类似的还有三维、四维</p></li><li><p>list中一个元素也没有，就是空list，长度为0</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">classmates = ['Bob','Tom','Jack','Rose']len(classmates) # 4classmates[1] # 'Tom'classmates[-3] # 'Tom'classmates.append('SQX') # ['Bob','Tom','Jack','Rose','SQX']classmates.insert(1,'John') # ['Bob', 'John', 'Tom', 'Jack', 'Rose', 'SQX']classmates.pop() # ['Bob', 'John', 'Tom', 'Jack', 'Rose']classmates.pop(-1) # ['Bob', 'John', 'Tom', 'Jack']classmates[0] = 'Nick' # ['Nick', 'John', 'Tom', 'Jack']project = ['java','php','python','c']stu = ['Jack', 253.6, 176, [15, 20, 'B'], 'A']stu[3] # [15, 20, 'B']stu[3][2] # 'B'L = []len(L) # 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>另一种有序列表叫元组，tuple一旦被初始化就不能修改，代码更加安全</p></li><li><p>tuple的陷阱：当定义一个tuple时，tuple的元素必须被确定下来</p></li><li><p>元组不能像列表一样增加、删除等，访问方法一样</p></li><li><p>要定义一个只有1个元素的tuple，如果是数字，防止与数学公式中括号产生歧义，必须加一个逗号<code>,</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">tup = (1,2,'a')tup[0] # 1tup[-3] # 1t = (1,) # (1,)len(tup) # 3tt = ('a','b',['A','B'])tt[2][0] # 'A'tt[2][0] = 'X't[2][1] = 'Y'# ('a', 'b', ['X', 'Y'])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。要创建一个内容也不变的tuple，就必须保证tuple的每一个元素本身也不能变。</p></li></ol><h3 id="五、条件判断"><a href="#五、条件判断" class="headerlink" title="五、条件判断"></a>五、条件判断</h3><ol><li><p>if…else / if… elif…else （注意缩进和冒号）</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if &lt;条件判断1&gt;:    &lt;执行1&gt;elif &lt;条件判断2&gt;:    &lt;执行2&gt;elif &lt;条件判断3&gt;:    &lt;执行3&gt;else:    &lt;执行4&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>if判断条件可以简写，只要x是非零数值、非空字符串、非空list等，就判断为<code>True</code>，否则为<code>False</code>。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">if x:print('True')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>input()返回的数据类型是<code>str</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s = input('your birth:')birth = int(s)if birth &lt; 2000:    print('00前')else:    print('00后')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="六、循环"><a href="#六、循环" class="headerlink" title="六、循环"></a>六、循环</h3><ol><li><p><code>for x in ...</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">project = ['java','php','python','c','go']for x in project:    print(x)sum = 0for i in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] :    sum = sum + iprint(sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果计算1-100的累加和，上述方法有点困难，Python提供一个<code>range()</code>函数，生成一个整数序列，再通过<code>list()</code>函数转换为list</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sum = 0score = list(range(101))for x in score:    sum += xprint(sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>while</code></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">sum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>break</code>提前跳出循环</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">n = 1while n &lt;= 100:    if n &gt; 10: # 当n = 11时，条件满足，执行break语句        break # break语句会结束当前循环    print(n)    n = n + 1print('END')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>continue</code>跳过当前的这次循环，直接开始下一次循环</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">n = 0while n &lt; 10:    n = n + 1    if n % 2 == 0:        continue    print(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>python执行死循环，按<code>Ctrl+C</code>推出程序</p></li></ol><h3 id="七、使用dict和set"><a href="#七、使用dict和set" class="headerlink" title="七、使用dict和set"></a>七、使用dict和set</h3><ol><li><p>字典<code>dict</code>，Python内置了字典，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。</p></li><li><p>把数据放入dict的方法，除了初始化时指定外，还可以通过key放入</p></li><li><p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</p></li><li><p>key不存在，dict就会报错，可以通过<code>in</code>判断key是否存在，或者通过dict提供的<code>get()</code>方法，如果key不存在，可以返回<code>None</code>，或者自己指定的value</p></li><li><p>删除一个key，用<code>pop(key)</code>方法，对应的value也会从dict中删除</p></li><li><p>dict内部存放的顺序和key放入的顺序是没有关系</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">d = {'nusqx': 175, 'Bob': 172, 'Nice': 162}d['nusqx']d['Jack'] = 167d['Jack'] = 160'sqx' in d # Falsed.get('nusqx') #175d.get('pei') #d.get('Nice', 163) # 162d.pop('Nice') # 162# {'nusqx': 175, 'Bob': 172, 'Jack': 160}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>和list比较，dict有以下几个特点：</p><ul><li>查找和插入的速度极快，不会随着key的增加而变慢；</li><li>需要占用大量的内存，内存浪费多</li></ul><p>list相反：</p><ul><li>查找和插入的时间随着元素的增加而增加；</li><li>占用空间小，浪费内存很少</li></ul><p>dict是用<strong>空间来换取时间</strong>的一种方法</p></li><li><p>dict的key必须是<strong>不可变对象</strong></p></li><li><p>通过key计算位置的算法称为哈希算法（Hash），要保证hash的正确性，作为key的对象就不能变</p></li><li><p>集合<code>set</code>也是一组key的集合，但不存储value</p></li><li><p>要创建一个set，需要提供一个list作为输入集合</p></li><li><p>显示的顺序也不表示set是有序的，重复元素在set中自动被过滤</p></li><li><p>通过<code>add(key)</code>方法可以添加元素到set中，可以重复添加，但不会有效果</p></li><li><p>通过<code>remove(key)</code>方法可以删除元素</p></li><li><p>两个set可以做数学意义上的交集、并集等操作</p></li><li><p>set和dict的唯一区别仅在于没有存储对应的value，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">s = set([1, 2, 3])s = set([1, 1, 2, 2, 3, 3])s.add(4)s.remove(1)s1 = set([1,2,4])s1 &amp; ss1 | s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>不可变对象</strong>，str是不变对象，而list是可变对象</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">a = ['c', 'b', 'a']a.sort()#a: ['a', 'b', 'c']a = 'abc'a.replace('a', 'A') # 'Abc'a # 'abc'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">#定义元组t1 = (1,2,3)   #内容不变t2 = (1,[2,3]) #指向不变，但内容可以发生改变#以dict为例d1 = {t1:1}out: {(1, 2, 3): 1}   # 创建了key为元组t1，value为1的字典d2 = {t2:2}TypeError: unhashable type: 'list'  # 报错：list是不可使用哈希算法的类型。#sets1 = set(t1) # {1, 2, 3}s2 = set(t2) #TypeError: unhashable type: 'list'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：虽然t2作为tuple是不可变对象，但是这里的不可变是指“指向不变”，内容是可以发生改变的。这里为了保证Hash算法，key应同时满足<strong>内容不变和指向不变</strong>。t1是内容和指向都不变的元组，因此可以作为dict的key，而t2则不可以。</p></blockquote></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见算法</title>
      <link href="/2021/05/18/algorithm-md/"/>
      <url>/2021/05/18/algorithm-md/</url>
      
        <content type="html"><![CDATA[<h2 id="常见算法"><a href="#常见算法" class="headerlink" title="常见算法"></a>常见算法</h2><p>Hash，音译为哈希，是一个典型的利用空间换取时间的算法，把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。贪心算法（又称贪婪算法）是指在对问题求解时，总是做出在当前看来是最好的选择。博弈/博弈论，又称为对策论（Game Theory）、赛局理论等，既是现代数学的一个新分支，也是运筹学的一个重要学科。</p><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ol><li>把任意长度的输入（又叫做预映射pre-image）通过散列算法变换成固定长度的输出，该输出就是散列值。</li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li><p>态规划的基本思想是：问题的最优解如果可以由子问题的最优解推导得到，则可以先求解子问题的最优解，在构造原问题的最优解；若子问题有较多的重复出现，则可以自底向上从最终子问题向原问题逐步求解。</p></li><li><p>动态规划的特点：</p><p>a) 把原始问题划分成一系列子问题；</p><p>b) 求解每个子问题仅一次，并将其结果保存在一个表中，以后用到时直接存取，不重复计算，节省计算时间</p><p>c) 自底向上地计算。</p><p>d) 整体问题最优解取决于子问题的最优解（状态转移方程）（将子问题称为状态，最终状态的求解归结为其他状态的求解）</p></li><li><p>线性动规，区域动规，树形动规，背包动规。</p></li><li><p>最大不下降子序列</p></li></ol><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ol><li><p>在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p></li><li><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p></li><li><p>贪心算法的思想如下：</p><p>a)建立数学模型来描述问题；</p><p>b)把求解的问题分成若干个子问题；</p><p>c)对每一子问题求解，得到子问题的局部最优解；</p><p>d)把子问题的解局部最优解合成原来解问题的一个解。</p></li></ol><h3 id="博弈算法"><a href="#博弈算法" class="headerlink" title="博弈算法"></a>博弈算法</h3><ol><li><p>博弈论主要研究公式化了的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法，博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。</p></li><li><p>博弈问题的特点</p><p>a) 博弈模型为两人轮流决策的非合作博弈。即两人轮流进行决策，并且两人都使用最优策略来获取胜利</p><p>b) 博弈是有限的。即无论两人怎样决策，都会在有限步后决出胜负</p><p>c) 公平博弈。即两人进行决策所遵循的规则相同</p></li><li><p>几种常用的博弈论模型有：巴什博弈，威佐夫博弈，斐波那契博弈，尼姆博弈</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法分析</title>
      <link href="/2020/10/15/ds-algorithm-md/"/>
      <url>/2020/10/15/ds-algorithm-md/</url>
      
        <content type="html"><![CDATA[<p>数据结构与算法分析，以C语言为描述语言，涵盖各种数据结构，如栈、队列、树、图以及一些算法的分析。</p><h2 id="第一章-数据结构和算法分析"><a href="#第一章-数据结构和算法分析" class="headerlink" title="第一章 数据结构和算法分析"></a>第一章 数据结构和算法分析</h2><h3 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h3><ol><li>逻辑结构：线性结构、非线性结构。</li><li>存储结构：顺序（随机存取）、链式（顺序存取）、索引、散列。</li><li>运算：运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。</li><li>抽象数据类型：ADT只是一个数学模型以及定义在模型上的一组操作。</li></ol><h3 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h3><ol><li><p>五特征：有穷性、确定性、可行性、输入、输出。</p></li><li><p>时间复杂度：时间复杂度表示一个程序运行所需要的时间，其具体需要在机器环境中才能得到具体的值，但我们一般并不需要得到详细的值，只是需要比较快慢的区别即可，为此，我们需要引入时间频度（语句频度）的概念。时间频度中，n称为问题的规模，当n不断变化时,时间频度T(n)也会不断变化。一般情况下，算法中的基本操作重复次数的是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n)，使得当n趋近于无穷大时，T(n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n))，称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。</p></li><li><p>空间复杂度：指运行完一个程序所需内存的大小，其包括两个部分。</p><ul><li>固定部分：这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间，属于静态空间。</li><li>可变空间：这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等，大小与算法有关。</li></ul></li><li><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n).</p></li></ol><p><strong>程序 = 数据结构 + 算法</strong></p><h3 id="三、内存分配"><a href="#三、内存分配" class="headerlink" title="三、内存分配"></a>三、内存分配</h3><ol><li><p>常规的内存分配，使用到释放的过程如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#define SIZE 5int main(void){    int *p;    p = (int*)malloc(SIZE*sizeof(int));//申请SIZE歌整形大小的内存并返回首地址给p    if(p == NULL)        exit(1);    p[0] = 123;//为空间添加数据    printf("%d",p[0]);    free(p);//释放p所指空间，但p依旧存在为野指针    p = NULL;//此时不是野指针        return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>C语言中malloc函数从堆上动态分配内存，free函数释放已分配的对应内存。</p></li></ol><h2 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h2><h3 id="一、单链表"><a href="#一、单链表" class="headerlink" title="一、单链表"></a>一、单链表</h3><ol><li><p>单链表，每个结点可以使用结构体struct设计：</p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303142208041.png" alt="image-20230314220830970" style="zoom: 33%;"><p>Data为数据元素，可以是数组、基本数据类型、结构体，next为指向下一个结点的指针，链尾指向NULL。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">//定义结点类型typedef struct Node{    int data;    struct Node *next;} Node, *LinkedList;//Node表示结点类型，LinkedList表示指向Node结点类型的指针类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单链表初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">LinkedList listinit(){/*初始化是创建一个单链表的前置结点并向后逐步添加结点，即申请结点的空间，同时对一个结点赋以空值(NULL)*/    Node *L;    L = (Node*)malloc(sizeof(Node));//开辟空间    if(L==NULL)    {        printf("申请失败");     exit(0);    }    L -&gt; next = NULL;//指针指向空    return L;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>创建单链表</p><p>单链表的创建分为头插入法和尾插入法两种，都是利用指针指向下一个结点元素的方式进行逐个创建，使用头插入法最终得到的结果是逆序的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">LinkedList ListCreatH(LinkedList h){//头插法，插在表头，头结点之后    Node *L;    L = h;    int x;    while(scanf("%d", &amp;x) != EOF)//输入类型正确,按ctrl+z结束    {        Node * p;        p = (Node*)malloc(sizeof(Node));        p -&gt; data = x;        p -&gt; next = L -&gt; next;//L--&gt;|2|--&gt;|1|--&gt;NULL        L -&gt; next = p;    }    return L;}LinkedList ListCreatT(LinkedList L){//尾插法    Node *r = L;//r始终指向终端结点，开始指向头结点    int x;    while(scanf("%d", &amp;x) != EOF)//按ctrl+z结束    {        Node *p;        p = (Node*)malloc(sizeof(Node));        p -&gt; data = x;        r -&gt; next = p;//L--&gt;|1|--&gt;|2|--&gt;NULL        r = p;    }    r -&gt; next = NULL;//尾插法细结    return L;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>遍历单链表</p><p>遍历单链表可以查询元素、修改元素、获取元素个数、打印链表数据。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void printList(LinkedList L){//遍历打印    Node *p = L -&gt; next;    int i = 0;    while(p)    {        printf("第%d个元素值为%d\n", ++i, p -&gt; data);        p = p -&gt; next;    }}LinkedList ListReplace(LinkedList L, int x, int k){//将链表中值为x的元素改为k    Node *p = L -&gt; next;    while (p)    {        if(p -&gt; data == x)            p -&gt; data = k;        p = p -&gt; next;    }    return L;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单链表插入操作</p><p>插入到第i个位置</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">LinkedList ListInsert(LinkedList L, int i, int x){//插入到第i位置操作    LinkedList p, s;    p = L;    int j = 0;    while (p &amp;&amp; j &lt; i-1)//p为第i-1处    {        p = p -&gt; next;        ++j;    }    if (!p || j &gt; i-1)    {        printf("不存在该位置\n");        exit(0);    }    s = (Node*)malloc(sizeof(Node));    s -&gt; data = x;    s -&gt; next = p -&gt; next;    p -&gt; next = s;    return L;    // Node *pre;    // pre = L;    // int count;    // for(count = 1; count &lt; i; count++)    //     pre = pre -&gt; next;    // Node *p;    // p = (Node*)malloc(sizeof(Node));    // p -&gt; data = x;    // p -&gt; next = pre -&gt; next;    // pre -&gt; next = p;    //return L;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>单链表的删除操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">LinkedList ListDelete(LinkedList L, int x){//删除值为x的结点    Node *p, *pre;    p = L -&gt; next;    while(p -&gt; data != x)    {        pre = p;        p = p -&gt;next;    }    pre -&gt; next = p -&gt; next;    free(p);    return L;}int ListDeletei(LinkedList L, int i){//删除第i处的结点，并取出值    LinkedList pre, q;//q为第i个结点    pre = L;//pre指向第i个结点的前驱    int j = 0;    int e;    while ((pre-&gt;next) &amp;&amp; j &lt; i-1)    {        pre = pre -&gt; next;        ++j;    }    if (!(pre-&gt;next) || j &gt; i-1)    {        printf("不存在该位置\n");        exit(0);    }    q = pre -&gt; next;    pre -&gt; next = q -&gt; next;    e = q -&gt; data;    free(q);    return e;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、双向链表"><a href="#二、双向链表" class="headerlink" title="二、双向链表"></a>二、双向链表</h3><ol><li><p>双向链表简称为双链表，在单链表的基础上，对于每一个结点设计一个前驱结点，前驱结点与前一个结点相互连接，构成一个链表。从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303190937023.png" alt="image-20230319093746932"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct DouList{    int data;    struct DouList *pre;    struct DouList *next;} DouList, *DoubList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双链表的创建</p><p>双链表的头结点是有元素的，与带头结点的单链表不同。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DoubList initLin(DoubList head){    int num, pos = 1, in;    //结点数，当前位置，输入数据    printf("input node num:");    scanf("%d", &amp;num);    if(num &lt; 1)        return NULL;    head = (DouList*)malloc(sizeof(DouList));    head -&gt; pre = NULL;    head -&gt; next = NULL;    printf("input No.%d:", pos++);    scanf("%d", &amp;in);    head -&gt; data = in;    DouList *list = head;    while (pos &lt;= num)    {        DouList * body = (DouList*)malloc(sizeof(DouList));        body -&gt; pre = NULL;        body -&gt; next = NULL;        printf("input No.%d:", pos++);        scanf("%d", &amp;in);        body -&gt; data = in;        list -&gt; next = body;        body -&gt; pre = list;        list = list -&gt; next;        return head;    }    return head;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双链表的插入操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">DoubList InsertList(DoubList head, int x, int i){    DouList *temp = (DouList*)malloc(sizeof(DouList));    temp -&gt; data = x;    temp -&gt; pre = NULL;    temp -&gt; next = NULL;    if(1 == i)//插入到表头    {        temp -&gt; next = head;        head -&gt; pre = temp;        head = temp;    }    else    {        DouList *body = head;        for(int j = 1; j &lt; i-1; j++)        {             body = body -&gt; next;        }        if (body -&gt; next == NULL)//插在表尾        {            body -&gt; next = temp;            temp -&gt; pre = body;        }        else        {            body -&gt; next -&gt; pre = temp;            temp -&gt; next = body -&gt; next;            body -&gt; next = temp;            temp -&gt; pre = body;        }    }    return head;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双链表的删除操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Deletev(DoubList head, int x){    DouList *p = head;    if(p -&gt; data == x &amp;&amp; p -&gt; next == NULL)    {        printf("only one number\n");        head = NULL;        free(p);        printf("delete done!\n");    }    else if(p -&gt; data == x &amp;&amp; p -&gt; next != NULL)    {//first        head = head -&gt; next;        head -&gt; pre = NULL;        free(p);        printf("delete done!\n");    }    else if(p -&gt; next != NULL)    {        while (p -&gt; data != x)            p = p -&gt; next;        if(p -&gt; next == NULL)//最后一个元素        {            p -&gt; pre -&gt; next = NULL;            free(p);            printf("delete done!\n");        }        else        {            p -&gt; pre -&gt; next = p -&gt; next;            p -&gt; next -&gt; pre = p -&gt; pre;            free(p);            printf("delete done!\n");        }        }    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>双向链表的遍历</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void printDList(DoubList head){    DouList *p = head;    int pos = 1;    while (p)    {        printf("No.%d: %d\n", pos++, p -&gt; data);        p = p -&gt; next;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="三、循环单链表"><a href="#三、循环单链表" class="headerlink" title="三、循环单链表"></a>三、循环单链表</h3><ol><li><p>非循环链表的尾结点指向空（NULL），而循环链表的尾指针指向的是链表的开头。通过将单链表的尾结点指向头结点的链表称之为循环单链表（Circular linkedlist）。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct CirList{    int data;    struct list *next;}CirList; //data为存储的数据，next指针为指向下一个结点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>循环单链表初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">CirList *initClist(){    CirList *head = (CirList*)malloc(sizeof(CirList));    if(head == NULL)    {        printf("create failed!");        exit(0);    }    else    {        head -&gt; next = NULL;        return head;    }}//main()中CirList *L = initClist();L -&gt; next = L;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>循环链表的创建</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int insert_List(CirList *head){//插在表尾    int data;       printf("请输入要插入的元素：");    scanf("%d",&amp;data);      CirList *node=initClist();    node-&gt;data=data;    //初始化一个新的结点，准备进行链接      if(head!=NULL)    {        CirList *p=head;        //找到最后一个数据        while(p-&gt;next!=head)        {            p=p-&gt;next;        }        p-&gt;next=node;        node-&gt;next=head;        return 1;    }else    {        printf("头结点已无元素\n");        return 0;    } }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>循环单链表的插入</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">CirList *insert_list(CirList *head,int pos,int data){    //三个参数分别是链表，位置，参数    CirList *node=initlist();  //新建结点    CirList *p=head;       //p表示新的链表    CirList *t;    t=p;    node-&gt;data=data;    if(head!=NULL)    {        for(int i=1;i&lt;pos;i++){            t=t-&gt;next;  //走到需要插入的位置处        }        node-&gt;next=t-&gt;next;        t-&gt;next=node;        return p;    }    return p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>循环单链表的删除</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int delete_list(CirList *head) //删除元素{    if(head == NULL)     {        printf("链表为空！\n");        return 0;    }//建立临时结点存储头结点信息（目的为了找到退出点）//不这么建立的化需要使用一个数据进行计数标记，计数达到链表长度时自动退出//循环链表当找到最后一个元素的时候会自动指向头元素，这是我们不想让他发生的    CirList *temp = head;              CirList *ptr = head-&gt;next;    int del;    printf("请输入你要删除的元素：");    scanf("%d",&amp;del);      while(ptr != head) //至少有两个元素    {        if(ptr-&gt;data == del)         {            if(ptr-&gt;next == head)             {                 temp-&gt;next = head;                free(ptr);                return 1;            }            temp-&gt;next = ptr-&gt;next;    //核心删除操作代码            free(ptr);            //printf("元素删除成功！\n");            return 1;        }        temp = temp-&gt;next;//temp是ptr的前驱结点        ptr = ptr-&gt;next;    }    printf("没有找到要删除的元素\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>循环单链表的遍历</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int display(CirList *head)//遍历元素{    if(head != NULL)     {        CirList *p  = head;        while(p-&gt;next != head)//遍历头结点到，最后一个数据        {            printf("%d ",p-&gt;next-&gt;data);            p = p-&gt;next;        }        return 1;    }     else     {        printf("头结点为空!\n");        return 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h2><h3 id="一、栈"><a href="#一、栈" class="headerlink" title="一、栈"></a>一、栈</h3><ol><li><p>栈（stack）是一个线性的数据结构，规定这个数据结构只允许在其中一端进行操作，并禁止直接访问除这一端以外的数据。</p></li><li><p>栈结点的设计</p><p>除单链表的结构外，额外添加一个结构体，其主要功效就是设定允许操作元素的指针以及确定栈何时为空：</p><ul><li>法一：包括了一个永远指向栈头的指针top和一个计数器count记录元素个数，当count为0时为空；</li><li>法二：设计一个指针top和一个指针bottom分别指向栈头和栈尾，两者指向同一个空间时为栈为空。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define TRUE 1#define FALSE 0#define MAXSIZE 20 /* 存储空间初始分配量 */typedef int Status;typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int *//* 链栈结点结构 */typedef struct StackNode{ElemType data;struct StackNode *next;}StackNode;/* 链栈结构 */typedef struct LinkStack{StackNode  *top;int count;}LinkStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">Status initStack(LinkStack **stack){// 注意要给链栈分配内存*stack = (LinkStack *)malloc(sizeof(LinkStack));(*stack)-&gt;top = NULL; // 链栈的空其实就是 top=NULL 的时候(*stack)-&gt;count = 0;return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>入栈</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 进栈操作Status push(LinkStack *stack, ElemType e){StackNode  *s = (StackNode  *)malloc(sizeof(StackNode));s-&gt;data = e;s-&gt;next = stack-&gt;top; // 把当前的栈顶元素赋值给新结点的直接后继，见图中①stack-&gt;top = s; // 将新的结点s赋值给栈顶指针，见图中②stack-&gt;count++;return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>出栈</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 出栈操作Status pop(LinkStack *stack, ElemType *e){StackNode  *p;if (isEmpty(stack))return FALSE;*e = stack-&gt;top-&gt;data;p = stack-&gt;top; // p用来存储要删除的栈顶结点，见图中③stack-&gt;top = stack-&gt;top-&gt;next; // 使得栈顶指针下移一位，指向后一结点，见图中④free(p); // 释放结点pstack-&gt;count--;return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>栈的遍历：在栈不为空的情况下，一次从栈顶元素向下访问，直到指针指向空（即到栈尾）为结束。（逆序输出）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 遍历栈操作Status traverseStack(LinkStack *stack){StackNode  *p;p = stack-&gt;top;while (p){printf("%d ", p-&gt;data);p = p-&gt;next;}printf("\n");return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其他</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 清除栈操作Status clearStack(LinkStack *stack){StackNode  *p;StackNode  *q;p = stack-&gt;top;while (p){q = p;p = p-&gt;next;free(q);}stack-&gt;count = 0;return TRUE;}// 判断是否为空栈Status isEmpty(LinkStack *stack){return stack-&gt;count == 0 ? TRUE : FALSE;}// 获得栈顶元素Status getTop(LinkStack *stack, ElemType *e){if (stack-&gt;top == NULL)return FALSE;else*e = stack-&gt;top-&gt;data;return TRUE;}// 获得栈的长度int getLength(LinkStack *stack){return stack-&gt;count;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>顺序栈</p><ul><li>栈空时：栈顶指针（top）= -1；</li><li>栈满时：栈顶指针（top）= MAXSIZE-1；</li><li>栈未满：就是栈中存在元素，top 指针还未达到 MAXSIZE-1。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define TRUE 1#define FALSE 0#define MAXSIZE 20 /* 存储空间初始分配量 */typedef int ElemType; // ElemType类型根据实际情况而定，这里假设为int /* 顺序栈结构 */typedef struct SeqStack{ElemType data[MAXSIZE];    int top; /* 用于栈顶指针 */}SeqStack;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>其他</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 初始化栈操作Status initStack(SeqStack **stack){*stack = (SeqStack *)malloc(sizeof(SeqStack));(*stack)-&gt;top = -1;return TRUE;}// 进栈操作Status push(SeqStack *stack, const ElemType e){if (stack-&gt;top == MAXSIZE - 1) // 判断是否栈满{return FALSE;}stack-&gt;top++; // 栈顶指针加1stack-&gt;data[stack-&gt;top] = e; // 将新插入元素赋值给栈顶空间return TRUE;}// 出栈操作Status pop(SeqStack *stack, ElemType *e){if (stack-&gt;top == -1) // 判断是否空栈return FALSE;*e = stack-&gt;data[stack-&gt;top];   // 将要删除的栈顶元素赋值给estack-&gt;top--;               // 栈顶指针减1return TRUE;}// 遍历栈操作Status traverseStack(SeqStack *stack){for (int i = 0; i &lt;= stack-&gt;top; i++)printf("%d ", stack-&gt;data[i]);printf("\n");return TRUE;}// 清空栈操作Status clearStack(SeqStack *stack){stack-&gt;top = -1;return TRUE;}// 判断是否为空Status isEmpty(SeqStack *stack){return stack-&gt;top == -1 ? TRUE : FALSE;}// 获得栈顶元素Status getTop(SeqStack *stack, ElemType *e){if (stack-&gt;top == -1)return FALSE;else*e = stack-&gt;data[stack-&gt;top];return TRUE;}// 获取栈的长度int getLength(SeqStack *stack){return stack-&gt;top + 1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、队列"><a href="#二、队列" class="headerlink" title="二、队列"></a>二、队列</h3><ol><li><p>顺序队列：用数组存储队列，为了避免当只有一个元素时，队头和队尾重合使得处理变得麻烦，所以引入两个指针：front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，当 front=rear 时，为空队列。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int *//* 循环队列的顺序存储结构 */typedef struct SeqQueue{    ElemType data[MAXSIZE];    int front;      /* 头指针 */    int rear;       /* 尾指针，若队列不空，指向队列尾元素的下一个位置 */}SeqQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>解决 “假溢出” 的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为顺序循环队列。</p><ul><li>办法一是设置一个标志变量 flag， 当 front == rear，且 flag = 0 时为队列空，当 front== rear，且 flag= 1 时为队列满。</li><li>办法二是当队列空时，条件就是 front = rear，当队列满时，我们修改其条件，保留一个元素空间。也就是说，队列满时，数组中还有一个空闲位置。</li></ul></li><li><p>针对法二：若队列的最大尺寸为 QueueSize，那么队列满的条件是<code>(rear+1) % QueueSize == front</code> ，因此通用的计算队列长度公式为：<code>(rear - front + QueueSize) % QueueSize</code> 。</p><p>注意：front 指针和 rear 指针后移不能直接使用 ++，而要使用<code>Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE</code>，因为到达数组尾后需要移动到数组开头。</p></li><li><p>程序实现</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define TRUE 1#define FALSE 0#define MAXSIZE 5 /* 存储空间初始分配量 */typedef int Status;typedef int ElemType; /* ElemType类型根据实际情况而定，这里假设为int */// 初始化队列操作Status initQueue(SeqQueue *Q){Q-&gt;front = 0;Q-&gt;rear = 0;return  TRUE;}// 入队操作Status enQueue(SeqQueue *Q, const ElemType e){// 判断队列是否已满if ((Q-&gt;rear + 1) % MAXSIZE == Q-&gt;front) return FALSE;Q-&gt;data[Q-&gt;rear] = e; // 将元素e赋值给队尾Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE; // rear指针向后移一位置，若到最后则转到数组头部return  TRUE;}// 出队操作Status deQueue(SeqQueue *Q, ElemType *e){// 判断是否为空队if (Q-&gt;front == Q-&gt;rear) return FALSE;*e = Q-&gt;data[Q-&gt;front]; // 将队头元素赋值给eQ-&gt;front = (Q-&gt;front + 1) % MAXSIZE; // front指针向后移一位置,若到最后则转到数组头部return  TRUE;}// 遍历队列操作Status tarverseQueue(const SeqQueue Q){int cur = Q.front; // 当前指针while (cur != Q.rear) // 直到cur指向了队尾元素的下一个位置，即Q.rear，结束循环{printf("%d ", Q.data[cur]);cur = (cur + 1) % MAXSIZE; // 当前指针向后推移}printf("\n");return TRUE;}// 清空队列操作Status clearQueue(SeqQueue *Q){Q-&gt;front = Q-&gt;rear = 0;return TRUE;}// 判断是否为空队列Status isEmpty(const SeqQueue Q){return Q.front == Q.rear ? TRUE : FALSE;}// 获得队头元素Status getHead(const SeqQueue Q, ElemType *e){if (Q.front == Q.rear) // 判断是否为空队列return FALSE;*e = Q.data[Q.front];return TRUE;}// 获得队列的长度int getLength(const SeqQueue Q){return  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>链队列</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef int QElemType; /* QElemType类型根据实际情况而定，这里假设为int *//* 结点结构 */typedef struct QNode {ElemType data;struct QNode *next;}QNode;/* 队列的链表结构 */typedef struct{QNode *front; // 队头指针QNode *rear; // 队尾指针}LinkQueue;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>基本操作：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 初始化链队列操作Status initQueue(LinkQueue *Q){Q-&gt;front = Q-&gt;rear = (QNode *)malloc(sizeof(QNode));if (!Q-&gt;front)return FALSE;Q-&gt;front-&gt;next = NULL;return TRUE;}// 入队操作Status enQueue(LinkQueue *Q, ElemType e){QNode *s = (QNode *)malloc(sizeof(QNode));if (!s)return FALSE;s-&gt;data = e;s-&gt;next = NULL;Q-&gt;rear-&gt;next = s;// 把拥有元素e的新结点s赋值给原队尾结点的后继，见图中①Q-&gt;rear = s; // 把当前的s设置为队尾结点，rear指向s，见图中②return TRUE;}/*出队操作就是头结点的后继结点出队，将头结点的后继改为它后面的结点，若链表除头结点外只剩一个元素时，则需将rear指向头结点*/Status deQueue(LinkQueue *Q, ElemType *e){QNode *p;if (Q-&gt;front == Q-&gt;rear)return FALSE;p = Q-&gt;front-&gt;next; // 将欲删除的队头结点暂存给p，见图中①*e = p-&gt;data; // 将欲删除的队头结点的值赋值给eQ-&gt;front-&gt;next = p-&gt;next; // 将原队头结点的后继p-&gt;next赋值给头结点后继，见图中②if (Q-&gt;rear == p) // 若队头就是队尾，则删除后将rear指向头结点，见图中③Q-&gt;rear = Q-&gt;front;free(p);return TRUE;}// 遍历队列操作Status tarverseQueue(const LinkQueue Q){QNode *p;p = Q.front-&gt;next;while (p){printf("%d ", p-&gt;data);p = p-&gt;next;}printf("\n");return TRUE;}// 销毁队列操作Status destroyQueue(LinkQueue *Q){while (Q-&gt;front){Q-&gt;rear = Q-&gt;front-&gt;next;free(Q-&gt;front);Q-&gt;front = Q-&gt;rear;}return TRUE;}// 清空队列操作Status clearQueue(LinkQueue *Q){QNode *p;QNode *q;Q-&gt;rear = Q-&gt;front;p = Q-&gt;front-&gt;next;Q-&gt;front-&gt;next = NULL;while (p){q = p;p = p-&gt;next;free(q);}return TRUE;}// 判断是否为空队列Status isEmpty(const LinkQueue Q){return Q.front == Q.rear ? TRUE : FALSE;}// 获得队头元素Status getHead(const LinkQueue Q, ElemType *e){QNode *p;if (Q.front == Q.rear)return FALSE;p = Q.front-&gt;next;*e = p-&gt;data;return TRUE;}// 获得队列的长度int getLength(const LinkQueue Q){int i = 0;QNode *p;p = Q.front;while (Q.rear != p){i++;p = p-&gt;next;}return i;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第四章-字符串"><a href="#第四章-字符串" class="headerlink" title="第四章 字符串"></a>第四章 字符串</h2><h3 id="一、字符串模式匹配"><a href="#一、字符串模式匹配" class="headerlink" title="一、字符串模式匹配"></a>一、字符串模式匹配</h3><ol><li><p>暴力匹配</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">/* 在文本txt中寻找模式pat 若找到则返回文本中**模式出现时的首个字母的索引i** 若没找到（也就是txt中不存在pat模式），返回-1 */ int baolipipei(char txt[], char pat[]){    int i, j;    int len1 = strlen(txt);    int len2 = strlen(pat);    for (i = 0; i &lt;= len1-len2; i++)    {        for (j = 0; j &lt; len2; j++)            if(txt[i+j] != pat[j])                break;        if(j == len2)            return i;    }    return -1;}//O(m*n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>KMP算法</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;void kmp_next(char x[], int m, int next[]);int kmp(char x[], int m, char y[], int n);int main(void){    char zhu[30] = "googooglegobgooglegooogoogle";    char pi[10] = "google";    //cout &lt;&lt; strlen(pi) &lt;&lt; endl;    int count = kmp(pi, 6, zhu, 28);    cout &lt;&lt; count &lt;&lt; endl;    return 0;}void kmp_next(char x[], int m, int next[])//x为模式串，m为模式串长{    next[1] = 0;    int i = 1, j = 0; //i是next的索引，j是x的下标，1开始    // while (i &lt;= m)    // {    //     if(j == 0 || x[i] == x[j]) next[++i] = ++j;    //     else j = next[j];    // }    //优化    while(i &lt;= m)    {        if(j == 0 || x[i] == x[j])        {            j++;            i++;            if(x[i] == x[j])//当两个字符相同时，就跳过                next[i] = next[j];            else                next[i] = j;        }        else            j = next[j];    }}int kmp(char x[], int m, char y[], int n)//x模式串，y主串{    int i, j;    int ans = 0;    int next[100];    kmp_next(x, m, next);    i = j = 0;    while(i &lt; n)    {//x[j]是模式串        if(j == 0 || y[i] == x[j])        {            i++;            j++;        }        else j = next[j];        // while(j != 0 &amp;&amp; y[i] != x[j])        //     j = next[j];        // i++;        // j++;        if(j &gt;= m)        {            ans++;            j = next[j];        }    }    return ans;//返回模式串在主串中出现次数，在主串位置是i-m}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、C-string类"><a href="#二、C-string类" class="headerlink" title="二、C++string类"></a>二、C++string类</h3><ol><li><p>C++中的string字符串类型</p><p>在C++中，通过模板类的操作创建了<strong>string类</strong></p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    string str;       //创建空字符串      string str1 = "Hello hhhcpp.com";    cout&lt;&lt; str1 &lt;&lt;endl;   //Hello hhhcpp.com      string str2(str1);    cout &lt;&lt; str2 &lt;&lt; endl;   //Hello hhhcpp.com      string str3(str1,6);//丛str1[6]开始取到结束    cout &lt;&lt; str3 &lt;&lt; endl;   //hhhcpp.com      string str4(str1,6,6);//丛str1[6]开始取6个    cout &lt;&lt; str4 &lt;&lt; endl;   //hhhcpp      string str5(5,'D'); //str5为5个D    cout &lt;&lt; str5 &lt;&lt; endl;   //DDDDD      string str6(str1.begin(),str1.end());     cout &lt;&lt; str6 &lt;&lt; endl;   //Hello hhhcpp.com    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>比较和连接</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">string str1 = "Hello";string str2 = "Hello";if(str1 == str2)     cout &lt;&lt; "两者相等" &lt;&lt; endl;else    cout &lt;&lt; "两者不相等" &lt;&lt; endl;string totalystring = "a";cout &lt;&lt; totalystring + "b" + "c" + "d" &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>获取长度length，获取当前字符串的长度</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">str.length();//C中strlrn(str)str.size();//获取大小size，获取当前字符串的大小，某种意义上由于字符串的每一个字符开辟的空间均完全相等，因此size可以代替length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>strlen(str)</code>和<code>str.length()</code>和<code>str.size()</code>三者的区别</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">strlen(str)和str.length()和str.size()都可以求字符串长度。其中 str.length() 和 str.size() 是用于求string类对象的成员函数，而 strlen(str) 是用于求字符数组的长度，其参数是char*，当数组名作为参数传入时，实际上数组就退化成指针了。返回的长度大小不包括 '\0'。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>其他</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">//判断是否为空emptystr.empty();//填充内容resize：原型为void resize(int len,char chr)把字符串当前大小置为len，多去少补，多出的字符chr填充不足的部分，resize将会修改该字符串的占用空间。string str = "HEllo";str.resize(8,'K');cout &lt;&lt; str &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="三、矩阵乘法"><a href="#三、矩阵乘法" class="headerlink" title="三、矩阵乘法"></a>三、矩阵乘法</h3><ol><li><p>两个矩阵的乘法仅当第一个矩阵A的列数和另一个矩阵B的行数相等时才能定义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;#define ROW 100#define COL 100int main(){int a[ROW][COL], b[ROW][COL], c[ROW][COL];int i, j, k, m, n, q, p;cin &gt;&gt; m &gt;&gt; n; // 输入第一个矩阵行数列数cin &gt;&gt; p &gt;&gt; q; // 输入第二个矩阵行数列数for (i = 0; i &lt; m; ++i)for (j = 0; j &lt; n; ++j)cin &gt;&gt; a[i][j]; // 输入第一个矩阵for (i = 0; i &lt; p; ++i)for (j = 0; j &lt; q; ++j)cin &gt;&gt; b[i][j]; // 输入第二个矩阵for (i = 0; i &lt; m; ++i) // 矩阵相乘{for (j = 0; j &lt; q; ++j){c[i][j] = 0;for (k = 0; k &lt; n; ++k)c[i][j] += a[i][k] * b[k][j];}}for (i = 0; i &lt; m; ++i) // 输出相乘后的矩阵{for (j = 0; j &lt; q; ++j)cout &lt;&lt; c[i][j] &lt;&lt; " ";cout &lt;&lt; endl;}return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>卷积：用一个模板和另一个模板对比，进行卷积运算。目的是是目标与目标之间的差距变得更大，卷积在数字图像处理中常见的应用为锐化和边缘提取。</p><ul><li>假设一个卷积核h，将其倒置（翻转180°）</li></ul><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303221809189.png" alt="矩阵翻转"></p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303221819171.png" alt="image-20230322181931132" style="zoom:80%;"><ul><li><p>有一个待处理矩阵x：</p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303221815453.png" alt="image-20230322181521426" style="zoom:80%;"></li><li><p>h*x = Y：将卷积核h的中心对准x的第一个元素，然后对应元素相乘后相加，没有元素的地方补0。</p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303221822796.png" alt="image-20230322182256722" style="zoom:67%;"></li><li><p>Y11 = 1<em>0+2</em>0+1<em>0+0</em>0+0<em>1+0</em>2+-1<em>0+-2</em>5+-1*6=-16.</p></li><li><p>每个元素都像这样计算出来就可以得到一个输出矩阵，就是卷积结果。</p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303221824559.png" alt="image-20230322182451531" style="zoom: 67%;"></li><li><p>零填充，单位滑动。</p></li></ul></li></ol><h2 id="第五章-树"><a href="#第五章-树" class="headerlink" title="第五章 树"></a>第五章 树</h2><h3 id="一、树的性质"><a href="#一、树的性质" class="headerlink" title="一、树的性质"></a>一、树的性质</h3><ol><li><p>树是一种非线性数据结构，树是由结点或顶点和边组成的(可能是非线性的)且不存在着任何环的一种数据结构。没有结点的树称为空(null或empty)树。一棵非空的树包括一个根结点，还(很可能)有多个附加结点，所有结点构成一个多级分层结构。</p></li><li><p>树的定义：n个结点组成的有限集合。n=0，空树；n&gt;0,1个根结点，m个互不相交的有限集，每个子集为根的子树。</p></li><li><p>树：</p><ul><li><p>结点的度：树中某个结点的子树的个数。</p></li><li><p>树的度：树中各结点的度的最大值。</p></li><li><p>分支结点：度不为零的结点。</p></li><li><p>叶子结点：度为零的结点。</p></li><li><p>路径：i-&gt;j；路径长度：路径经过结点数目减1。</p></li><li><p>孩子结点：某结点的后继结点；双亲结点：该结点为其孩子结点的双亲结点（父母结点）；兄弟结点：同一双亲的孩子结点；子孙结点：某结点所有子树中的结点；祖先结点：从树结点到该结点的路径上的结点。</p></li><li><p>结点的层次：根结点为第一层（以此类推）；树的高度：树中结点的最大层次。</p></li><li><p>有序树：树中结点子树按次序从左向右安排，次序不能改变；无序树：与之相反</p></li><li><p>森林：互不相交的树的集合。</p></li></ul></li><li><p>树的性质：</p><ul><li>树的结点树为所有结点度数（边）加1（加根结点）。</li><li>度为m的树中第i层最多有m^(i-1)个结点。</li><li>高度为h的m叉树至多(m^h-1)/(m-1)个结点。</li><li>具有n个结点的m叉树的最小高度为logm( n(m-1) + 1 ) 向上取整。</li></ul></li></ol><h3 id="二、二叉树的性质"><a href="#二、二叉树的性质" class="headerlink" title="二、二叉树的性质"></a>二、二叉树的性质</h3><ol><li><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的<strong>左子树</strong>和<strong>右子树</strong>组成。</p></li><li><p><strong>二叉树的特点</strong></p><p>1）每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</p><p>2）左子树和右子树是有顺序的，次序不能任意颠倒。</p><p>3）即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p></li><li><p><strong>二叉树的性质</strong></p><p>性质1：二叉树第i层上的结点数目最多为 2的(i-1)次方个节点(i≥1)。<br>性质2：深度为k的二叉树至多有2的k次方-1个结点(k≥1)。<br>性质3：包含n个结点的二叉树的高度至少为log2 (n+1)。<br>性质4：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1。</p></li><li><p><strong>满二叉树</strong></p><p>满二叉树：在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>满二叉树的特点有：</p><p>1）叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</p><p>2）非叶子结点的度一定是2。</p><p>3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</p></li><li><p><strong>完全二叉树</strong>：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p></li></ol><h3 id="三、二叉树的操作"><a href="#三、二叉树的操作" class="headerlink" title="三、二叉树的操作"></a>三、二叉树的操作</h3><ol><li><p>设计代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;typedef struct biTreeNode{    int data;    struct biTreeNode *left;    struct biTreeNode *right;} Node;typedef struct{    biTreeNode *root;} Tree;void create(Tree *tree, int value);void inorder(biTreeNode *node);int main(void){    Tree tree;    tree.root = NULL;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        int temp;        cin &gt;&gt; temp;        create(&amp;tree, temp);    }    inorder(tree.root);    return 0;}void create(Tree *tree, int value){    biTreeNode *node = (biTreeNode *)malloc(sizeof(biTreeNode));    node-&gt;data = value;    node-&gt;left = NULL;    node-&gt;right = NULL;    if (tree-&gt;root == NULL)        tree-&gt;root = node;    else    {        biTreeNode *temp = tree-&gt;root;        while (temp != NULL)        {            if (value &lt; temp-&gt;data) // 小于就进左孩子                if (temp-&gt;left == NULL)                {                    temp-&gt;left = node;                    break;                }                else                {                    temp = temp-&gt;left;                }            else // 大于为右孩子            {                if (temp-&gt;right == NULL)                {                    temp-&gt;right = node;                    break;                }                else                {                    temp = temp-&gt;right;                }            }        }    }}void inorder(biTreeNode *node){    if (node != NULL)    {        inorder(node-&gt;left);        cout &lt;&lt; node-&gt;data;        inorder(node-&gt;right);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>二叉树的遍历</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">//先序遍历 根左右void preorder(biTreeNode *node){    if (node != NULL)    {        cout &lt;&lt; node-&gt;data &lt;&lt; " ";        preorder(node-&gt;left);        preorder(node-&gt;right);    }}//中序遍历 左根右void inorder(biTreeNode *node){    if (node != NULL)    {        inorder(node-&gt;left);        cout &lt;&lt; node-&gt;data &lt;&lt; " ";        inorder(node-&gt;right);    }}//后序遍历 左右根void postorder(biTreeNode *node){    if (node != NULL)    {        postorder(node-&gt;left);        postorder(node-&gt;right);        cout &lt;&lt; node-&gt;data &lt;&lt; " ";    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>前缀表达式（波兰式）：符号迁移，波兰式表达形式不需要括号，利用栈中缀转后缀。借助括号的形式表示优先级。</p></li><li><p>深度优先遍历（DFS）</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">vector&lt;int&gt; a;    // 记录每次排列vector&lt;int&gt; book; // 标记是否被访问int n;void DFS(int cur, int k, vector&lt;int&gt; &amp;nums){    if (cur == k)    { // k个数已经选完，可以进行输出等相关操作        for (int i = 0; i &lt; cur; i++)        {            printf("%d ", a[i]);        }        return;    }    for (int i = 0; i &lt; k; i++)    { // 遍历 n个数，并从中选择k个数        if (book[nums[i]] == 0)        {                          // 若没有被访问            a.push_back(nums[i]);  // 选定本输，并加入数组            book[nums[i]] = 1;     // 标记已被访问            DFS(cur + 1, n, nums); // 递归，cur+1            book[nums[i]] = 0;     // 释放，标记为没被访问，方便下次引用            a.pop_back();          // 弹出刚刚标记为未访问的数        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="四、森林"><a href="#四、森林" class="headerlink" title="四、森林"></a>四、森林</h3><ol><li><p>森林：m（&gt;=0）棵互不相交的树的集合 ，可以是0棵树。</p></li><li><p>树转换成二叉树：左孩子右兄弟法。树转换成二叉树其右子树一定为空。</p></li><li><p>二叉树转换成树：左孩子右兄弟法，逆。</p></li><li><p>二叉树与森林转换：左孩子右兄弟。</p></li></ol><h3 id="五、哈夫曼树"><a href="#五、哈夫曼树" class="headerlink" title="五、哈夫曼树"></a>五、哈夫曼树</h3><ol><li><p><strong>哈夫曼树</strong>（Huffman Tree），又名：最优二叉树。给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p></li><li><p>名词解释：</p><ul><li>路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。</li><li>路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。</li><li>结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。</li><li>结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。</li><li><strong>树的带权路径长度</strong>为树中所有叶子结点的带权路径长度之和。通常记作 “WPL”。</li></ul></li><li><p>哈夫曼树的建立与查找算法</p><p>查找算法：查找权重值最小的两个结点的思想是：从待处理数据的头部位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：</p><ul><li>如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；</li><li>如果介于两个结点权重值之间，替换原来较大的结点；</li></ul></li><li><p>哈夫曼编码：(Huffman Coding)，又称霍夫曼编码，是一种编码方式，可变字长编码(VLC)的一种。</p><ul><li>主要目的是根据使用频率来最大化节省字符（编码）的存储空间。</li><li>霍夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合，也包括文件传输的场合。</li><li>如果考虑到进一步节省存储空间，就应该将出现概率大（占比多）的字符用尽量少的0-1进行编码，也就是更靠近根（节点少），这也就是最优二叉树-哈夫曼树。</li></ul></li></ol><h2 id="第六章-图"><a href="#第六章-图" class="headerlink" title="第六章 图"></a>第六章 图</h2><h3 id="一、图的基本概念"><a href="#一、图的基本概念" class="headerlink" title="一、图的基本概念"></a>一、图的基本概念</h3><ol><li>一个图G是一个二元组，即序偶&lt;V,E&gt;，或记作G=&lt;V,E&gt; ，其中V是有限非空集合，称为G的顶点集,V中的元素称为顶点或结点；E称为 G的边的集合，所有的边ei都属于E，都有v中的结点与之对应，称ei为 G的边。</li><li>图的基本概念<ul><li>无向图：每条边都是无向边的图。</li><li>有向图：每条边都是有向边的图。</li><li>混合图：在一个图中，有些边是有向边，另一些边是无向边。</li><li>有限图：一个图的点集和边集都是有穷集的图。</li><li>零图：边集为空集的图。</li><li>平凡图：仅有一个结点而没有边构成的图。</li><li>关联：若有ei=(u,v) 且ei属于E ，则称u是和v相关联的。</li><li>孤立点：无边关联的点。</li><li>自环：若一条边所关联的两个结点重合，则称此边为自环。</li><li>邻接：关联于同一条边的两个点称为邻接的；关联于同一个点的两条边和 是邻接的（或相邻的）。</li></ul></li><li>在任意图中，度数为奇数的点必然有偶数个或0个。</li><li>所有点入度之和等于出度之和。</li></ol><h3 id="二、图的存储"><a href="#二、图的存储" class="headerlink" title="二、图的存储"></a>二、图的存储</h3><ol><li><p>无向图的邻接矩阵</p><p>邻接矩阵存在以下缺点</p><p>a) 浪费空间—— 存稀疏图（点很多而边很少）有大量无效元素</p><p>b) 浪费时间—— 统计稀疏图中一共有多少条边</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;const int maxn = 105;int adj[maxn][maxn] = {0}; // 定义邻接矩阵int x, y; // 输入两条边int n, m; // 供输入n对边 ,m个顶点 (x,y &lt;= m)int main(){    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; n; i++)    {        cin &gt;&gt; x &gt;&gt; y;        adj[x - 1][y - 1] = 1;        adj[y - 1][x - 1] = 1;    }    for (int i = 0; i &lt; m; i++)    {        for (int j = 0; j &lt; m; j++)        {            cout &lt;&lt; adj[i][j] &lt;&lt; ' ';        }        cout &lt;&lt; endl;    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>有向图的邻接表</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;malloc.h&gt;#define maxSize 1000using namespace std;typedef struct ArcNode{    int adjvex;    struct ArcNode *nextarc;} ArcNode;typedef struct{    int data;    ArcNode *firstarc;} Vnode;// 可以利用结构体整体结构，也可以拆分结构体变为单独搜索typedef struct{    Vnode adjlist[maxSize];    int n, e;} AGraph;AGraph *graph;// 插入链表末尾void insertNode(ArcNode *node, ArcNode *newNode){    ArcNode *p = node;    while (p-&gt;nextarc != NULL)    {        p = p-&gt;nextarc;    }    p-&gt;nextarc = newNode;}void create(){    graph = (AGraph *)malloc(sizeof(AGraph));    cout &lt;&lt; "输入顶点的数目: " &lt;&lt; endl;    cin &gt;&gt; graph-&gt;n;    cout &lt;&lt; "输入图中边的数目: " &lt;&lt; endl;    cin &gt;&gt; graph-&gt;e;    int u = -1, v = -1;    for (int i = 0; i &lt; graph-&gt;n; i++)    {        graph-&gt;adjlist[i].firstarc = NULL;    }    ArcNode *node;    for (int i = 0; i &lt; graph-&gt;e; i++)    {        cout &lt;&lt; "请输入联通点A与B" &lt;&lt; endl;        cin &gt;&gt; u &gt;&gt; v;        node = (ArcNode *)malloc(sizeof(ArcNode));        node-&gt;adjvex = v;        node-&gt;nextarc = NULL;        graph-&gt;adjlist[u].data = u;        if (graph-&gt;adjlist[u].firstarc == NULL)        {            // 边            graph-&gt;adjlist[u].firstarc = node;        }        else        {            // 插入边            insertNode(graph-&gt;adjlist[u].firstarc, node);        }    }}void travseTree(){    for (int i = 0; i &lt; graph-&gt;n; i++)    {        if (graph-&gt;adjlist[i].firstarc != NULL)        {            cout &lt;&lt; "与" &lt;&lt; i &lt;&lt; "连接的点有：";            ArcNode *p = graph-&gt;adjlist[i].firstarc;            while (p != NULL)            {                cout &lt;&lt; p-&gt;adjvex &lt;&lt; " ";                p = p-&gt;nextarc;            }            cout &lt;&lt; endl;        }    }}int main(void){    create();    travseTree();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>BFS</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void BFSL(int pos, pGraph G, int visited[30]) // 从pos点开始进行广度优先遍历无向图{    int queue[G-&gt;Vnum];     // 队列辅助BFS遍历    int head = 0, tail = 0; // 队头、队尾指针    Arcnode *p;    queue[tail] = pos;    visited[pos] = 1; // 标记遍历过    tail++;    while (head != tail)    {        pos = queue[head]; // 出队操作        head++;        printf("%d ", pos);        p = G-&gt;vertice[pos].firstarc;        while (p != NULL)        {            if (visited[p-&gt;adjvex] == 0) // 判断是否遍历过            {                queue[tail] = p-&gt;adjvex; // 入队操作                visited[p-&gt;adjvex] = 1;  // 标记遍历过                tail++;            }            p = p-&gt;next;        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>DFS</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">void dfs()//参数用来表示状态  {      if(到达终点状态)      {          ...//根据需求添加          return;      }      if(越界或者是不合法状态)          return;      if(特殊状态)//剪枝，去除一些不需要访问的场景，不一定i俺家        return ;    for(扩展方式)      {          if(扩展方式所达到状态合法)          {              修改操作;//根据题意来添加              标记；              dfs（）；              (还原标记)；              //是否还原标记根据题意              //如果加上（还原标记）就是 回溯法          }        }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="三、最小生成树"><a href="#三、最小生成树" class="headerlink" title="三、最小生成树"></a>三、最小生成树</h3><ol><li>将给出的所有点连接起来（即从一个点可到任意一个点），且连接路径之和最小的图叫最小生成树。最小生成树属于一种树形结构（树形结构是一种特殊的图），或者说是直链型结构，因为当n个点相连，且路径和最短，那么将它们相连的路一定是n-1条。</li><li>普利姆(<strong>Prim</strong>)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的极小连通子图。</li><li>普利姆算法加点，克鲁斯卡尔算法加边。</li></ol><h3 id="四、最短路径"><a href="#四、最短路径" class="headerlink" title="四、最短路径"></a>四、最短路径</h3><ol><li>迪杰斯特拉(Dijkstra)算法</li><li>弗洛伊德(Floyd)算法</li></ol><h2 id="第七章-查找算法"><a href="#第七章-查找算法" class="headerlink" title="第七章 查找算法"></a>第七章 查找算法</h2><h3 id="一、顺序查找"><a href="#一、顺序查找" class="headerlink" title="一、顺序查找"></a>一、顺序查找</h3><ol><li><p>从一些数据之中，找到一个特殊的数据的实现方法。查找算法与遍历有极高的相似性，唯一的不同就是查找算法可能并不一定会将每一个数据都进行访问，有些查找算法如二分查找等，并不需要完全访问所有的数据。</p></li><li><p>顺序查找：线性的从一个端点开始，将所有的数据依次访问，并求得所需要查找到的数据的位置，此时，线性查找可以称呼为遍历。</p></li><li><p>代码实现</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;iosteam&gt;using namespace std;int main(){    int Shangping[6]={10,10,9,10,10,10}    for(int i=0;i&lt;6;i++){        if(Shangping[i]==9){            printf("找到次品，他的位置在：%d",i+1);        }    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、二分查找"><a href="#二、二分查找" class="headerlink" title="二、二分查找"></a>二、二分查找</h3><ol><li><p><strong>二分查找</strong>也称<strong>折半查找</strong>（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列，注意必须要是有序排列。</p></li><li><p>二分查找的基本思想是将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x,如果x&gt;a[n/2],则只要在数组a的右半部搜索x</p></li><li><p>代码实现</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 二分查找算法，找不到就返回-1，找到了就返回值int binary_search(int *list, int len, int target){    int low = 0;    int hight = len - 1;    int middle;    while (low &lt;= hight)    {        middle = (low + hight) / 2;        if (list[middle] = target)        {            printf("已找到该值，数组下标为:%d\n", middle);            return list[middle];        }        else if (list[middle] &gt; target)        {            hight = middle - 1;        }        else if (list[middle] &lt; target)        {            low = middle + 1;        }    }    printf("未找到该值");    return -1;}int main(){    int a[] = {2, 4, 5, 8, 9, 44};    int b = binary_search(a, sizeof(a) / 4, 5);    printf("b=%d\n", b);    printf("Hello world!\n");    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="三、分块查找"><a href="#三、分块查找" class="headerlink" title="三、分块查找"></a>三、分块查找</h3><ol><li><p>分块查找</p><p>分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况，其核心有二索引表，二是分块处理。</p></li><li><p>分块查找要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。假设是按关键码值非递减的，那么这种块与块之间必须满足已排序要求，实际上就是对于任意的i，第i块中的所有节点的关键码值都必须小于第i+1块中的所有节点的关键码值。此外，还要建立一个索引表，把每块中的最大关键码值作为索引表的关键码值，按块的顺序存放到一个辅助数组中，显然这个辅助数组是按关键码值费递减排序的。查找时，首先在索引表中进行查找，确定要找的节点所在的块。由于索引表是排序的，因此，对索引表的查找可以采用顺序查找或折半查找；然后，在相应的块中采用顺序查找，即可找到对应的节点。</p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231306632.png" alt="image-20230323130627544" style="zoom:80%;"></li></ol><h3 id="四、二叉排序树"><a href="#四、二叉排序树" class="headerlink" title="四、二叉排序树"></a>四、二叉排序树</h3><ol><li><p><strong>二叉排序树</strong>（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。该树属于一种输入数据就默认产生一种顺序的数据结构。</p></li><li><p>性质：</p><p>a) 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；</p><p>b) 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</p><p>c) 左、右子树也分别为二叉排序树；</p><p>即对于每一个根结点，其左孩子永远小于根，右孩子永远大于根。</p></li><li><p>代码实现</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 *//* 二叉树的二叉链表结点结构定义 */typedef struct BiTNode /* 结点结构 */{    int data;                        /* 结点数据 */    struct BiTNode *lchild, *rchild; /* 左右孩子指针 */} BiTNode, *BiTree;/* 递归查找二叉排序树T中是否存在key, *//* 指针f指向T的双亲，其初始调用值为NULL *//* 若查找成功，则指针p指向该数据元素结点，并返回TRUE *//* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */Status SearchBST(BiTree t, int key, BiTree f, BiTree *p){    if (!t) /*  查找不成功 */    {        *p = f;        return FALSE;    }    else if (key == t-&gt;data) /*  查找成功 */    {        *p = t;        return TRUE;    }    else if (key &lt; t-&gt;data)        return SearchBST(t-&gt;lchild, key, t, p); /*  在左子树中继续查找 */    else        return SearchBST(t-&gt;rchild, key, t, p); /*  在右子树中继续查找 */}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>插入</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">struct BiTree{    int data;    BiTree *lchild;    BiTree *rchild;};// 在二叉排序树中插入查找关键字keyBiTree *InsertBST(BiTree *t, int key){    if (t == NULL)    {        t = new BiTree();        t-&gt;lchild = t-&gt;rchild = NULL;        t-&gt;data = key;        return t;    }    if (key &lt; t-&gt;data)        t-&gt;lchild = InsertBST(t-&gt;lchild, key);    else        t-&gt;rchild = InsertBST(t-&gt;rchild, key);    return t;}// n个数据在数组d中，tree为二叉排序树根BiTree *CreateBiTree(BiTree *tree, int d[], int n){    for (int i = 0; i &lt; n; i++)        tree = InsertBST(tree, d[i]);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>删除</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, *//* 并返回TRUE；否则返回FALSE。 */Status DeleteBST(BiTree *T,int key){     if(!*T) /* 不存在关键字等于key的数据元素 */         return FALSE;    else    {        if (key==(*T)-&gt;data) /* 找到关键字等于key的数据元素 */             return Delete(T);        else if (key&lt;(*T)-&gt;data)            return DeleteBST(&amp;(*T)-&gt;lchild,key);        else            return DeleteBST(&amp;(*T)-&gt;rchild,key);      }}/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */Status Delete(BiTree *p){    BiTree q,s;    if((*p)-&gt;rchild==NULL) /* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */    {        q=*p; *p=(*p)-&gt;lchild; free(q);    }    else if((*p)-&gt;lchild==NULL) /* 只需重接它的右子树 */    {        q=*p; *p=(*p)-&gt;rchild; free(q);    }    else /* 左右子树均不空 */    {        q=*p; s=(*p)-&gt;lchild;        while(s-&gt;rchild) /* 转左，然后向右到尽头（找待删结点的前驱） */        {            q=s;            s=s-&gt;rchild;        }        (*p)-&gt;data=s-&gt;data; /*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */        if(q!=*p)            q-&gt;rchild=s-&gt;lchild; /*  重接q的右子树 */         else            q-&gt;lchild=s-&gt;lchild; /*  重接q的左子树 */        free(s);    }    return TRUE;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="五、平衡二叉树"><a href="#五、平衡二叉树" class="headerlink" title="五、平衡二叉树"></a>五、平衡二叉树</h3><ol><li><p>平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 其中最为经典当属AVL树。</p></li><li><p>平衡二叉树是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。</p></li><li><p>性质：</p><ul><li>它必须是一颗二叉查找树</li><li>它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。</li><li>若将二叉树节点的平衡因子BF定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有节点的平衡因子只可能为-1,0,1.</li><li>只要二叉树上有一个节点的平衡因子的绝对值大于1，那么这颗平衡二叉树就失去了平衡。</li></ul></li><li><p>通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。各个调整的方法分为LL型、RR型、LR型和RL型4种类型，其余的操作与一般的树进行插入和修改数据无异。</p></li><li><p>代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;  //结点设计 typedef struct Node {    int key;    struct Node *left;    struct Node *right;    int height;} BTNode;  int height(struct Node *N) {    if (N == NULL)        return 0;    return N-&gt;height;}  int max(int a, int b) {    return (a &gt; b) ? a : b;}  BTNode* newNode(int key) {    struct Node* node = (BTNode*)malloc(sizeof(struct Node));    node-&gt;key = key;    node-&gt;left = NULL;    node-&gt;right = NULL;    node-&gt;height = 1;    return(node);}  //ll型调整 BTNode* ll_rotate(BTNode* y) {    BTNode *x = y-&gt;left;    y-&gt;left = x-&gt;right;    x-&gt;right = y;      y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + 1;    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;      return x;}  //rr型调整 BTNode* rr_rotate(BTNode* y) {    BTNode *x = y-&gt;right;    y-&gt;right = x-&gt;left;    x-&gt;left = y;      y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + 1;    x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;      return x;}  //判断平衡int getBalance(BTNode* N) {    if (N == NULL)        return 0;    return height(N-&gt;left) - height(N-&gt;right);}  //插入结点&amp;数据BTNode* insert(BTNode* node, int key) {    if (node == NULL)        return newNode(key);      if (key &lt; node-&gt;key)        node-&gt;left = insert(node-&gt;left, key);    else if (key &gt; node-&gt;key)        node-&gt;right = insert(node-&gt;right, key);    else        return node;      node-&gt;height = 1 + max(height(node-&gt;left), height(node-&gt;right));      int balance = getBalance(node);      if (balance &gt; 1 &amp;&amp; key &lt; node-&gt;left-&gt;key) //LL型        return ll_rotate(node);      if (balance &lt; -1 &amp;&amp; key &gt; node-&gt;right-&gt;key)     //RR型        return rr_rotate(node);      if (balance &gt; 1 &amp;&amp; key &gt; node-&gt;left-&gt;key) {   //LR型        node-&gt;left = rr_rotate(node-&gt;left);        return ll_rotate(node);    }      if (balance &lt; -1 &amp;&amp; key &lt; node-&gt;right-&gt;key) {   //RL型        node-&gt;right = ll_rotate(node-&gt;right);        return rr_rotate(node);    }      return node;}  //遍历void preOrder(struct Node *root) {    if (root != NULL) {        printf("%d ", root-&gt;key);        preOrder(root-&gt;left);        preOrder(root-&gt;right);    }}  int main() {    BTNode *root = NULL;      root = insert(root, 2);    root = insert(root, 1);    root = insert(root, 0);    root = insert(root, 3);    root = insert(root, 4);    root = insert(root, 4);    root = insert(root, 5);    root = insert(root, 6);    root = insert(root, 9);    root = insert(root, 8);    root = insert(root, 7);      printf("前序遍历：");    preOrder(root);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第八章-排序"><a href="#第八章-排序" class="headerlink" title="第八章 排序"></a>第八章 排序</h2><h3 id="一、冒泡排序"><a href="#一、冒泡排序" class="headerlink" title="一、冒泡排序"></a>一、冒泡排序</h3><ol><li><p>从第一个元素开始逐个比较相邻的元素。如果第一个比第二个大（a[1]&gt;a[2]），就交换他们两个。</p><p>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。此时在这一点，最后的元素应该会是最大的数，我们也称呼一遍这样的操作为：一趟冒泡排序。</p><p>针对所有的元素重复以上的步骤，每一趟冒泡排序的最大值已放在最后，下一次操作则不需要将此最大值纳入计算计算。</p><p>持续对每次对越来越少的元素，重复上面的步骤，直到没有任何一对数字需要比较，即完成冒泡排序。</p><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231601871.png" alt="image-20230323160119801"></p><p>到了第四趟的时候，整个数据已经排序结束了，但是程序还在进行，直到第5，6，7趟结束程序才算真正的结束，这其实是一种浪费算力的表现。</p></li><li><p>代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;void bubble_sort(int a[], int n);int main(void){    int num[8] = {70, 50, 30, 20, 10, 70, 40, 60};    int n = 7;    bubble_sort(num, 7);    for (int i = 0; i &lt; n; i++)    {        cout &lt;&lt; num[i] &lt;&lt; endl;    }    return 0;}void bubble_sort(int a[], int n){    for (int i = 0; i &lt; n; i++)    {        for (int j = 0; j &lt; n - i; j++)        {            if (a[j] &gt; a[j + 1])                swap(a[j], a[j + 1]);        }//namespace std命名空间的使用，std自带了交换函数swap(a,b)    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最坏情况：O(n^2)</p><p>最好情况：O(n)</p><p>平均情况：O(n^2)</p><p>空间复杂度：S(n)=O(1)</p><p>稳定性：稳定排序</p></li></ol><h3 id="二、简单选择排序"><a href="#二、简单选择排序" class="headerlink" title="二、简单选择排序"></a>二、简单选择排序</h3><ol><li><p>设置两个记录i和j，i自数组第一个元素开始，j自i+1个元素开始。</p><p>接着j遍历整个数组，选出整个数组最小的值，并让这个最小的值和i的位置交换（如果i选择的元素是最小的则不需要交换），我们称这个过程为一趟选择排序。</p><p>i选中下一个元素(i++)，重复进行每一趟选择排序。</p><p>持续上述步骤，使得i到达n-1处，即完成排序 。</p></li><li><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231616770.png" alt="image-20230323161628741"></p></li><li><p>代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;void select_sort(int a[], int n);int main(void){    int num[8] = {2, 10, 9, 4, 8, 1, 6, 5};    int n = 8;    select_sort(num, n);    for (int i = 0; i &lt; n; i++)    {        cout &lt;&lt; num[i] &lt;&lt; endl;    }    return 0;}void select_sort(int a[], int n){    int min;    for (int i = 0; i &lt; n - 1; i++)    {        min = i;        for (int j = i + 1; j &lt; n; j++)        {            if (a[min] &gt; a[j])                min = j;        }        swap(a[min], a[i]);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>每一趟从待排序的数据元素中选出最小的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完，我们只需要进行n-1趟排序即可，因为最后剩下的一个数据一定是整体数据中最大的数据。</p></li><li><p>最坏情况：O(n^2)</p><p>最好情况：O(1)      //即不需要排序，本身已是正序</p><p>平均情况：O(n^2)</p><p>空间复杂度：S(n)=O(1)</p><p>稳定性：不稳定排序</p></li></ol><h3 id="三、直接插入排序"><a href="#三、直接插入排序" class="headerlink" title="三、直接插入排序"></a>三、直接插入排序</h3><ol><li><p>每一步将一个待排序的元素，按其排序码的大小，插入到前面已经排好序的一组元素的适当位置上去，直到元素全部插入为止。</p></li><li><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231631924.png" alt="image-20230323163134895"></p></li><li><p>代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;using namespace std;void insert_sort(int a[], int n);int main(void){    int a[8] = {70, 50, 30, 20, 10, 70, 40, 60};    int n = 8;    insert_sort(a, n);    for (int i = 0; i &lt; n; i++)    {        cout &lt;&lt; a[i] &lt;&lt; ' ';    }    return 0;}void insert_sort(int a[], int n){    int i, j;    for (i = 1; i &lt; n; i++)    {        if (a[i] &lt; a[i - 1]) // 后移插入        {            int temp = a[i];            for (j = i - 1; j &gt;= 0 &amp;&amp; a[j] &gt; temp; j--)            {                a[j + 1] = a[j];            }            a[j + 1] = temp; // 跳出是做过j--，但没有移动，所以j+1        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>最坏情况：O(N^2)</p><p>最好情况：O(N^2)</p><p>平均情况：O(N^2)</p><p>稳定性：稳定排序</p></li></ol><h3 id="四、希尔排序"><a href="#四、希尔排序" class="headerlink" title="四、希尔排序"></a>四、希尔排序</h3><ol><li><p>递减增量排序算法，是一种非稳定的更高效的插入排序。先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p></li><li><p>过程如下：</p><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol></li><li><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231659992.png" alt="image-20230323165944967"></p></li><li><p>代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">/* * 希尔排序 * 参数说明： *     a -- 待排序的数组 *     n -- 数组的长度 */#include &lt;iostream&gt;using namespace std;void shell_sort(int a[], int n);int main(void){    int num[8] = {80, 30, 60, 40, 20, 10, 50, 70};    int n = 8;    shell_sort(num, n);    for (int i = 0; i &lt; n; i++)    {        cout &lt;&lt; num[i] &lt;&lt; endl;    }    return 0;}void shell_sort(int a[], int n){    int i, j, gap;    // gap为步长，每次减为原来的一半。    for (gap = n / 2; gap &gt; 0; gap /= 2)    {        // 共gap个组，对每一组都执行直接插入排序        for (i = 0; i &lt; gap; i++)        {            for (j = i + gap; j &lt; n; j += gap)            {                // 如果a[j] &lt; a[j-gap]，则寻找a[j]位置，                // 并将后面数据的位置都后移。                if (a[j] &lt; a[j - gap])                {                    int tmp = a[j];                    int k = j - gap;                    while (k &gt;= 0 &amp;&amp; a[k] &gt; tmp)                    {                        a[k + gap] = a[k];                        k -= gap;                    }                    a[k + gap] = tmp;                }            }        }    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法时间复杂度</p><p>最坏情况：O(n^2)</p><p>最好情况：O(n)</p><p>平均情况：O(n^2)</p><p>稳定性：不稳定排序</p></li></ol><h3 id="五、堆排序"><a href="#五、堆排序" class="headerlink" title="五、堆排序"></a>五、堆排序</h3><ol><li><p>堆是一种非线性的数据结构，可以把堆看作一个数组，也可以被看作一个完全二叉树，通俗来讲堆其实就是利用完全二叉树的结构来维护的一维数组。</p></li><li><p>按照堆的特点可以把堆分为大顶堆和小顶堆</p><p>a)大顶堆：每个结点的值都大于或等于其左右孩子结点的值</p><p>b)小顶堆：每个结点的值都小于或等于其左右孩子结点的值</p></li><li><p>代码</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void max_heapify(int arr[], int start, int end){    // 建立父节点指标和子节点指标    int dad = start;    int son = dad * 2 + 1;    while (son &lt;= end)    {                                                  // 若子节点指标在范围内才做比较        if (son + 1 &lt;= end &amp;&amp; arr[son] &lt; arr[son + 1]) // 先比较两个子节点大小，选择最大的            son++;        if (arr[dad] &gt; arr[son]) // 如果父节点大于子节点代表调整完毕，直接跳出函数            return;        else        { // 否则交换父子内容再继续子节点和孙节点比较            swap(arr[dad], arr[son]);            dad = son;            son = dad * 2 + 1;        }    }}void heap_sort(int arr[], int len){    // 初始化，i从最后一个父节点开始调整    for (int i = len / 2 - 1; i &gt;= 0; i--)        max_heapify(arr, i, len - 1);    // 先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕    for (int i = len - 1; i &gt; 0; i--)    {        swap(arr[0], arr[i]);        max_heapify(arr, 0, i - 1);    }}int main(){    int arr[] = {3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6};    int len = (int)sizeof(arr) / sizeof(*arr);    heap_sort(arr, len);    for (int i = 0; i &lt; len; i++)        cout &lt;&lt; arr[i] &lt;&lt; ' ';    cout &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法时间复杂度</p><p>最坏情况：O(n^2)</p><p>最好情况：O(n)</p><p>平均情况：O(nlogn)</p><p>稳定性：不稳定排序</p></li></ol><h3 id="六、归并排序"><a href="#六、归并排序" class="headerlink" title="六、归并排序"></a>六、归并排序</h3><ol><li><p>将两个有序的数列合并成一个大的有序的序列。通过递归，层层合并，即为归并，归并排序的算法效率仅次于快速排序，是一种稳定的算法，需要建立两倍的数组空间，一般用于对总体而言无序，但是各子项又相对有序【并不是完全乱序】的情况比较适用。</p></li><li><p>a)申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</p><p>b)设定两个指针，最初位置分别为两个已经排序序列的起始位置</p><p>c)比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</p><p>重复步骤c直到某一指针超出序列尾</p><p>将另一序列剩下的所有元素直接复制到合并序列尾</p></li><li><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231754901.png" alt="image-20230323175449875"></p></li><li><p>代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">// 归并排序（C-递归版）void merge_sort_recursive(int arr[], int reg[], int start, int end) {    if (start &gt;= end)        return;    int len = end - start, mid = (len &gt;&gt; 1) + start;    int start1 = start, end1 = mid;    int start2 = mid + 1, end2 = end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    int k = start;    while (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2)        reg[k++] = arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    while (start1 &lt;= end1)        reg[k++] = arr[start1++];    while (start2 &lt;= end2)        reg[k++] = arr[start2++];    for (k = start; k &lt;= end; k++)        arr[k] = reg[k];}void merge_sort(int arr[], const int len) {    int reg[len];    merge_sort_recursive(arr, reg, 0, len - 1);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法时间复杂度</p><p>最坏情况O(nlogn)</p><p>最好情况O(nlogn)</p><p>平均情况O(nlogn)</p><p>空间复杂度O(n)  注：归并排序需要创建一个与原数组相同长度的数组来辅助排序</p></li></ol><h3 id="七、快速排序"><a href="#七、快速排序" class="headerlink" title="七、快速排序"></a>七、快速排序</h3><ol><li><p>首先在数组中选择一个基准点，然后分别从数组的两端扫描数组，设两个指示标志（low指向起始位置，high指向末尾)，首先从后半部分开始，如果发现有元素比该基准点的值小，就交换low和high位置的值，然后从前半部分开始扫描，发现有元素大于基准点的值，就交换low和high位置的值，如此往复循环，直到low&gt;=high,然后把基准点的值放到high这个位置。一次排序就完成了。</p><p>以后采用递归的方式分别对前半部分和后半部分排序，当前半部分和后半部分均有序时该数组就自然有序了。</p></li><li><p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231801529.png" alt="image-20230323180124494"></p></li><li><p>代码</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">void Quick_Sort(int *arr, int begin, int end){    if(begin &gt; end)        return;    int tmp = arr[begin];    int i = begin;    int j = end;    while(i != j){        while(arr[j] &gt;= tmp &amp;&amp; j &gt; i)            j--;        while(arr[i] &lt;= tmp &amp;&amp; j &gt; i)            i++;        if(j &gt; i){            int t = arr[i];            arr[i] = arr[j];            arr[j] = t;        }    }    arr[begin] = arr[i];    arr[i] = tmp;    Quick_Sort(arr, begin, i-1);    Quick_Sort(arr, i+1, end);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>算法时间复杂度</p><p>最坏情况：O(n^2)</p><p>最好情况：O(nlogn)</p><p>平均情况：O(nlogn)</p><p>稳定性：不稳定排序</p></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>   <img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303231804954.png" alt="image-20230323180441922"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C程序设计</title>
      <link href="/2019/03/16/c-cheng-xu-she-ji/"/>
      <url>/2019/03/16/c-cheng-xu-she-ji/</url>
      
        <content type="html"><![CDATA[<p>C语言是一种通用的、面向过程式的计算机程序设计语言。1972 年，为了移植与开发 UNIX 操作系统，丹尼斯·里奇在贝尔电话实验室设计开发了 C 语言。C是一种融合了控制特性的现代语言，其设计使得用户可以自然地采用自顶向下的规划，<code>结构化的编程</code>，以及<code>模块化的设计</code>。这种做法使得编写出的程序更可靠，更易懂。</p><h2 id="第一章-C语言概述"><a href="#第一章-C语言概述" class="headerlink" title="第一章 C语言概述"></a>第一章 C语言概述</h2><h3 id="一、C语言的特点"><a href="#一、C语言的特点" class="headerlink" title="一、C语言的特点"></a>一、C语言的特点</h3><ol><li><p>高效性</p><p>C程序紧凑且运行速度快，可以表现出通常只有汇编语言才具有的精细控制能力（汇编语言是特定的CPU设计所采用的一组内部指令的助记符。不同的CPU类型使用不同的汇编语言）。</p></li><li><p>可移植性</p><p>在一个系统上编写的C程序经过很少改动或不经修改就可以其他系统上运行。</p></li><li><p>强大的功能和灵活性</p></li><li><p>面向编程人员</p><p>它允许编程人员访问硬件，并可以操纵内存中的特定位，具有丰富的运算符，能够简洁地表达自己的意图</p></li></ol><h3 id="二、C程序的执行过程"><a href="#二、C程序的执行过程" class="headerlink" title="二、C程序的执行过程"></a>二、C程序的执行过程</h3><ol><li><p>c程序的生命周期是从一个高级c语言程序开始的，为了在系统上运行<code>.c</code>程序，每条c语句都必须被其他程序转化为一系列的低级机器语言指令。</p><img src="https://gitee.com/guluyu/picgo/raw/master/blog/202303291949263.png" alt="img" style="zoom: 67%;"></li><li><p>预处理阶段。预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。<code>#include &lt;stdio.h&gt;</code>命令告诉预处理器读取系统头文件<code>stdio.h</code>的内容，并将它直接插入到程序文本中。结果就得到另一个C程序，通常以<code>.i</code>作为文件扩展名。</p></li><li><p>编译阶段。编译器（ccl）将文本文件<code>.i</code>翻译成文本文件<code>.s</code>。它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种标准的文本格式确切地描述了一条低级机器语言指令。汇编语言为不同编译器提供了通用的输出语言。</p></li><li><p>汇编阶段。汇编器（as）将<code>.s</code>翻译成机器语言指令，并将结果保存在目标文件<code>.o</code>中。<code>.o</code>是一种二进制文件。它的字节编码是机器语言指令而不是字符。</p></li><li><p>链接阶段。hello程序调用printf函数。它是c编译器都会提供的标准c库中的一个函数。printf函数存在于一个名为printf.o的单独的预编译好的目标文件中，而这个文件必须以某种方式合并到我们的hello.o程序中。链接器就是负责这种合并的。</p></li></ol><h3 id="三、C程序实例"><a href="#三、C程序实例" class="headerlink" title="三、C程序实例"></a>三、C程序实例</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;     /*引入头文件*/int main(void)     /*一个简单的C程序*/{    int number;     /*定义个名字叫做number的变量*/    number=2014;     /*给number赋一个值*/    printf("Hello ! I am dotcpp.com\n");     /*调用printf()函数*/    printf("This year is %d\n",number);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li><p>C程序规定一个程序中有一个或多个函数，他们是C程序的基本模块。但必须有且只有一个main函数。因为C程序的执行将从main函数开始，到main函数结束而停止。</p></li><li><p>变量名：字母、数字、下划线组成，第一个字符不能是数字，区分大小写。</p></li></ol><h2 id="第二章-C语言的数据类型和基本输入输出"><a href="#第二章-C语言的数据类型和基本输入输出" class="headerlink" title="第二章 C语言的数据类型和基本输入输出"></a>第二章 C语言的数据类型和基本输入输出</h2><h3 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h3><ol><li><p><strong>常量</strong>是指程序在运行时其值不能改变的量。常量不占内存,在程序运行时它作为操作对象直接出现在运算器的各种寄存器中。</p></li><li><p><strong>变量</strong>是指在程序运行时其值可以改变的量。变量的功能就是存储数据。</p></li><li><p>C语言的基本数据类型为：整型、字符型、实数型。按其在计算机中的<code>存储方式</code>可被分为两个系列，即<strong>整数(integer)类型</strong>和<strong>浮点数(floating-point)类型</strong>。 </p><p>这三种类型之下分别是：short、int、long、char、float、double这六个关键字再加上两个符号说明符signed和unsigned就基本表示了C语言的最常用的数据类型。</p><p>32位操作系统下常见编译器下的数据类型大小及表示的数据范围：</p></li></ol><table><thead><tr><th align="center">类型名称</th><th align="center">类型关键字</th><th align="center">占字节数</th><th align="center">其他叫法</th><th align="center">表示的数据范围</th></tr></thead><tbody><tr><td align="center">字符型</td><td align="center">char</td><td align="center">1</td><td align="center">signed char</td><td align="center">-128 ~ 127</td></tr><tr><td align="center">无符号字符型</td><td align="center">unsigned char</td><td align="center">1</td><td align="center">none</td><td align="center">0 ~ 255</td></tr><tr><td align="center">整型</td><td align="center">int</td><td align="center">4</td><td align="center">signed int</td><td align="center">-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td align="center">无符号整型</td><td align="center">unsigned int</td><td align="center">4</td><td align="center">unsigned</td><td align="center">0 ~ 4,294,967,295</td></tr><tr><td align="center">短整型</td><td align="center">short</td><td align="center">2</td><td align="center">short int</td><td align="center">-32,768 ~ 32,767</td></tr><tr><td align="center">无符号短整型</td><td align="center">unsigned short</td><td align="center">2</td><td align="center">unsigned short int</td><td align="center">0 ~ 65,535</td></tr><tr><td align="center">长整型</td><td align="center">long</td><td align="center">4</td><td align="center">long int</td><td align="center">-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td align="center">无符号长整型</td><td align="center">unsigned long</td><td align="center">4</td><td align="center">unsigned long</td><td align="center">0 ~ 4,294,967,295</td></tr><tr><td align="center">单精度浮点数</td><td align="center">float</td><td align="center">4</td><td align="center">none</td><td align="center">3.4E +/- 38 (7 digits)</td></tr><tr><td align="center">双精度浮点数</td><td align="center">double</td><td align="center">8</td><td align="center">none</td><td align="center">1.7E +/- 308 (15 digits)</td></tr><tr><td align="center">长双精度浮点数</td><td align="center">long double</td><td align="center">10</td><td align="center">none</td><td align="center">1.2E +/- 4932 (19 digits)</td></tr><tr><td align="center">长整型</td><td align="center">long long</td><td align="center">8</td><td align="center">__int64</td><td align="center">-9223372036854775808~9223372036854775808</td></tr></tbody></table><h3 id="二、关键字"><a href="#二、关键字" class="headerlink" title="二、关键字"></a>二、关键字</h3><table><thead><tr><th align="center">C语言中的32个关键字</th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">auto</td><td align="center">double</td><td align="center">int</td><td align="center">struct</td></tr><tr><td align="center">break</td><td align="center">else</td><td align="center">long</td><td align="center">switch</td></tr><tr><td align="center">case</td><td align="center">enum</td><td align="center">register</td><td align="center">typedef</td></tr><tr><td align="center">char</td><td align="center">extern</td><td align="center">return</td><td align="center">union</td></tr><tr><td align="center">const</td><td align="center">float</td><td align="center">short</td><td align="center">unsigned</td></tr><tr><td align="center">continue</td><td align="center">for</td><td align="center">signed</td><td align="center">void</td></tr><tr><td align="center">default</td><td align="center">goto</td><td align="center">sizeof</td><td align="center">volatile</td></tr><tr><td align="center">do</td><td align="center">if</td><td align="center">static</td><td align="center">while</td></tr></tbody></table><h2 id="第三章-C语言中的基本输入输出"><a href="#第三章-C语言中的基本输入输出" class="headerlink" title="第三章 C语言中的基本输入输出"></a>第三章 C语言中的基本输入输出</h2><h3 id="一、字符的输入输出"><a href="#一、字符的输入输出" class="headerlink" title="一、字符的输入输出"></a>一、字符的输入输出</h3><ol><li><p><strong>putchar函数</strong>是<strong>字符输出函数</strong>，其功能是在终端（显示器）输出单个字符。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int putchar(int ch);//ch表示要输出的字符内容//返回值作用为：如果输出成功返回一个字符的ASCII码，失败则返回EOF即-1putchar(‘A’); /*输出大写字母A */putchar(x); /*输出字符变量x的值*/putchar(‘\n’); /*换行*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>getchar</strong>函数的功能是接收用户从键盘上输入的一个字符。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">getchar();//getchar会以返回值的形式返回接收到的字符。即该字符的ASCII码char c;  /*定义字符变量c*/c=getchar();  /*将读取的字符赋值给字符变量c*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、格式化输出"><a href="#二、格式化输出" class="headerlink" title="二、格式化输出"></a>二、格式化输出</h3><ol><li><p><code>printf函数</code>，按照用户指定的格式，把指定的数据输出到屏幕上</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf("格式控制字符串",输出表项);//格式控制字符串用来说明输出表项中各输出项的输出格式//输出表项列出了要输出的项，各输出项之间用 逗号 分开printf("%-2d",x);//负号表示左对齐(默认右对齐)，2表示占有两个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>格式控制字符串有两种：<strong>格式字符串</strong>和<strong>非格式字符串</strong>。</p><ul><li><p>非格式字符串在输出的时候原样打印;</p></li><li><p>格式字符串是以%打头的字符串，在<code>%</code>后面跟不同格式字符，用来说明输出数据的类型、形式、长度、小数位数等</p><blockquote><p>%[输出最小宽度] [.精度] [长度] 类型</p></blockquote><p><strong>常用的输出格式</strong>及含义如下：</p><table><thead><tr><th align="center">格式字符</th><th align="center">输出前缀时加’#’，如%#x</th></tr></thead><tbody><tr><td align="center">d , i</td><td align="center">以十进制形式输出有符号整数(正数不输出符号)</td></tr><tr><td align="center">o</td><td align="center">以八进制形式输出无符号整数(不输出前缀0)</td></tr><tr><td align="center">x</td><td align="center">以十六进制形式输出无符号整数(不输出前缀0x)</td></tr><tr><td align="center">u</td><td align="center">以十进制形式输出无符号整数</td></tr><tr><td align="center">f</td><td align="center">以小数形式输出单、双精度类型实数</td></tr><tr><td align="center">e</td><td align="center">以指数形式输出单、双精度实数</td></tr><tr><td align="center">g</td><td align="center">以%f或%e中较短输出宽度的一种格式输出单、双精度实数</td></tr><tr><td align="center">c</td><td align="center">输出单个字符</td></tr><tr><td align="center">s</td><td align="center">输出字符串</td></tr></tbody></table><pre class="line-numbers language-c" data-language="c"><code class="language-c">printf("%d\n",a);printf("0%o\n",a);printf("0x%x\n",a);printf("%5.2f\n",b);//输出宽度为5(包括小数点)，并包含2位小数。printf("%c\n",c);printf("The number is: %*d\n",width,number);//由程序来指定字段宽度printf("Weight = %*.*f\n",width,precision,weight);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li></ol><h3 id="三、格式化输入"><a href="#三、格式化输入" class="headerlink" title="三、格式化输入"></a>三、格式化输入</h3><ol><li><p><code>scanf函数</code>，按照格式字符串的格式，从键盘上把数据输入到指定的变量之中.</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">scanf("格式控制字符串",输入项地址列表);//格式控制字符串不能显示提示字符串//地址表项中的地址给出各变量的地址，地址是由地址运算符“&amp;”后跟变量名组成<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>sacnf函数和printf函数的不同</p><ul><li><p>格式说明符中，可以指定数据的宽度，但不能指定数据的精度</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">float a；scanf(“%10f”，&amp;a);  //正确scanf(“%10.2f”,&amp;a);  //错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>输入long类型数据时必须使用%ld，输入double数据必须使用%lf或%le</p></li><li><p>附加格式说明符<code>*</code>使对应的输入数据不赋给相应的变量</p><p>printf()把%f、%e、%e、%g同时用于float类型和double类型，而scanf()只是把他们用于float类型，而用于double类型时要求使用l(字母l)修饰符</p></li></ul></li><li><p>转换说明符</p><table><thead><tr><th align="center">转换说明符</th><th align="center"></th></tr></thead><tbody><tr><td align="center">%c</td><td align="center">把输入解释成一个字符</td></tr><tr><td align="center">%d</td><td align="center">把输入解释成一个有符号十进制整数</td></tr><tr><td align="center">%e,%f,%g,%a</td><td align="center">把输入解释成一个浮点数(%a是C99的标准)</td></tr><tr><td align="center">%E,%F,%G,%A</td><td align="center">把输入解释成一个浮点数(%A是C99的标准)</td></tr><tr><td align="center">%i</td><td align="center">把输入解释成一个有符号十进制整数</td></tr><tr><td align="center">%o</td><td align="center">把输入解释成一个有符号的八进制整数</td></tr><tr><td align="center">%p</td><td align="center">把输入解释成一个指针(一个地址)</td></tr><tr><td align="center">%s</td><td align="center">把输入解释成一个字符串：输入的内容以第一个非空白字符作为开始，并且包含直到下一个空白字符的全部字符</td></tr><tr><td align="center">%u</td><td align="center">把输入解释成一个无符号十进制整数</td></tr><tr><td align="center">%x,%X</td><td align="center">把输入解释称一个有符号十六进制整数</td></tr></tbody></table><p><code>*</code>在scanf()中提供截然不同的服务，当把它放在%和说明符字母之间时，它使函数<strong>跳过</strong>相应的输入项</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">scanf("%*d %*d %d",&amp;num);//用*跳过scanf接收的数字,num为最后一项<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="四、字符串接收-x2F-输出函数"><a href="#四、字符串接收-x2F-输出函数" class="headerlink" title="四、字符串接收/输出函数"></a>四、字符串接收/输出函数</h3><ol><li><p>可以用<code>gets()</code>直接往字符数组里接收字符串，scanf接收时的结束标志有空格和回车，而gets不包括空格（<strong>gets可以接收空格</strong>本身作为内容的一部分）</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *gets(char *str);//函数原型char str[100] = "\0";  printf("请输入字符串：\n");gets(str);printf("刚才输入的字符串是：\n");printf("%s\n", str);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>可以用<code>puts()</code>输出字符串</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int puts(const char *s);//函数原型char str[100] = "www.dotcpp.com";printf("%s\n", str);  puts(str);//字符串或者字符数组的地址传入puts<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第四章-运算符和表达式"><a href="#第四章-运算符和表达式" class="headerlink" title="第四章 运算符和表达式"></a>第四章 运算符和表达式</h2><h3 id="一、算数运算符"><a href="#一、算数运算符" class="headerlink" title="一、算数运算符"></a>一、算数运算符</h3><ol><li><p>加法+、减法-、乘法*、除法/、求模%、自增++、自减–</p></li><li><p>自增++自减–又称为“<strong>增量运算符</strong>”(increment operator)，如++，即将其操作数的值增加1。这个运算符以两种方式出现。在第一种方式中，++出现在它作用的变量的前面，这是<strong>前缀</strong>(prefix)模式；在第二种方式中，++出现在它作用的变量的后面，这是<strong>后缀</strong>(postfix)模式。区别在于值的增加这一动作发生的准确时间不同。前缀运算符，先执行自增或自减运算，再计算表达式的值；后缀运算符，则先计算表达式的值，再执行自增或自减运算。</p><table><thead><tr><th align="center">运算符</th><th align="center">符号</th><th align="center">操作</th><th align="center">用例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">加法</td><td align="center">+</td><td align="center">使它两侧的值加到一起</td><td align="center">1+2</td><td align="center">3</td></tr><tr><td align="center">减法</td><td align="center">-</td><td align="center">从它前面的数减去后面的数</td><td align="center">5-3</td><td align="center">2</td></tr><tr><td align="center">乘法</td><td align="center">*</td><td align="center">将它前面的数乘以后面的数</td><td align="center">2*3</td><td align="center">6</td></tr><tr><td align="center">除法</td><td align="center">/</td><td align="center">用它左边的值除以右边的值</td><td align="center">8/3</td><td align="center">2(整数的除法会丢掉小数部分)</td></tr><tr><td align="center">取模</td><td align="center">%</td><td align="center">求用它左边的值除以右边的数后的余数</td><td align="center">5%3</td><td align="center">2(%运算符两侧的操作数必须为整数)</td></tr></tbody></table></li><li><p>关键字<code>sizeof</code> 经常被人误认为函数，<strong>长度(求字节)运算符</strong>，sizeof是一种<strong>单目运算符</strong>，以字节为单位返回某操作数的大小，用来求某一类型变量的长度。其运算对象可以是任何<strong>数据类型</strong>或<strong>变量</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int intsize = sizeof(int);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="二、逻辑、条件、关系运算符"><a href="#二、逻辑、条件、关系运算符" class="headerlink" title="二、逻辑、条件、关系运算符"></a>二、逻辑、条件、关系运算符</h3><ol><li><p><strong>逻辑与&amp;&amp;<strong>、</strong>逻辑或||<strong>、</strong>逻辑非!</strong></p></li><li><p><code>?:</code>三目运算符，选择运算符。表达式1?表达式2:表达式3</p></li><li><p><strong>大于&gt;<strong>、</strong>小于&lt;**、**大于或等于&gt;=<strong>、</strong>小于或等于&lt;=<strong>、</strong>是否等于==<strong>、</strong>是否不等于!<strong>，比较结果是</strong>逻辑值</strong>，即非真即假，也就是非1即0</p></li><li><p>**语句(statement)<strong>是构造程序的基本部分。</strong>程序(program)**是一系列带有某种必须的标点语句集合。一个语句是一条完整的计算机指令。</p></li><li><p>在C中，<strong>表达式</strong>代表值，而<strong>语句</strong>代表给计算机的指令。</p></li><li><p><strong>表达式</strong>由运算符和操作数组成。最简单的表达式只是一个不带运算符的常量或者变量。</p></li></ol><h3 id="三、位运算符"><a href="#三、位运算符" class="headerlink" title="三、位运算符"></a>三、位运算符</h3><ol><li><p>C语言中位运算，顾名思义，是以数值的二进制位为单位进行操作的，包含&lt;&lt;（左移）、&gt;&gt;（右移）、~（按位取反）、&amp;（按位与）、|（按位或）、^（按位异或）共六种运算符。</p><table><thead><tr><th align="center">功能如下：</th><th align="center"></th></tr></thead><tbody><tr><td align="center">左移运算符&lt;&lt;</td><td align="center">向左（即高位）移位，右侧补0</td></tr><tr><td align="center">右移运算符&gt;&gt;</td><td align="center">向右（即低位）移位，左侧补0</td></tr><tr><td align="center">按位取反~</td><td align="center">如名，即0变1，1变0</td></tr><tr><td align="center">按位与&amp;</td><td align="center">相对应的两个位都为1则为1，反之为0</td></tr><tr><td align="center">按位或 |</td><td align="center">相对应的两个位至少有一个为1即为1，反之为0</td></tr><tr><td align="center">按位异或^</td><td align="center">相对应的两个位相同为0，相异（不同）为1</td></tr></tbody></table></li><li><p><strong>移位运算符的作用：</strong></p><ul><li>左移N位的本质是乘以2的N次方。</li><li>右移N位的本质是除以2的N次方。</li></ul></li><li><p><strong>按位与运算符&amp;</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">3 0000 0000  0000 0000  0000 0000  0000 00115 0000 0000  0000 0000  0000 0000  0000 0101&amp; ------------------------------------------  0000 0000  0000 0000  0000 0000  0000 0001<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按位与运算符的作用：</strong></p><p><strong>(1)清零：</strong></p><p>我们可以对某一个数与0进行按位与运算，由于两个位都为1才为1，因此最终全部位都变为0，起到清零的作用</p><p><strong>(2)取指定位：</strong></p><p>如某些存储场景下，“xxxx”，我们需要取出低1-3位，则可以让原数值与数字7(0111)进行按位与运算，得到的结果即是原数值的低1~3位的值。</p><p><strong>(3)判断奇偶：</strong></p><p>可以发现，数字的奇偶取决于二进制位的最低一位是1还是0，因此只需要与1按位与运算，判断是1是0即可得知奇偶。</p></li><li><p><strong>按位或运算符|</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">8 0000 0000  0000 0000  0000 0000  0000 10007 0000 0000  0000 0000  0000 0000  0000 0111&amp; ------------------------------------------  0000 0000  0000 0000  0000 0000  0000 1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按位或运算符的作用：</strong></p><p>对一个数字的指定位置为1，如“某个数字的第七位”表示开关，原先是0，需要改为1的状态，即可以将这个数字与64按位或，即可得到第七位变为1，其余位的值依旧不变。</p></li><li><p><strong>按位异或运算符^</strong>：相异，即不同则为1，反之为0。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">15 0000 0000  0000 0000  0000 0000  0000 111116 0000 0000  0000 0000  0000 0000  0001 0000^ ------------------------------------------   0000 0000  0000 0000  0000 0000  0001 1111<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>异或运算符的作用：</strong></p><p><strong>(1) 指定位数的翻转</strong></p><p>如想对某个数字的低4位进行翻转，则可以将这个数字与15（二进制为00001111）进行按位异或运算，既可以将原数字的低四位进行翻转，即高四位不变，低四位0变1，1变0。</p><p><strong>(2)与0异或还是原值</strong></p><p>一个数字与0进行异或，结果还是原值。与1异或为反。</p><p><strong>(3)交换两个数字</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;void swap(int *a,int *b);int main(void){    int a = 10;    int b = 5;    swap(&amp;a,&amp;b);    printf("a = %d, b = %d\n", a, b);    return 0;}void swap(int *a,int *b){    if (*a!=*b)    {        *a = *a ^ *b;        *b = *b ^ *a;        *a = *a ^ *b;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>取反运算符~<strong>：对数值的</strong>二进制位</strong>进行取反，是第一个<strong>单目运算符</strong>。</p></li></ol><h3 id="四、运算符的优先级和结合性"><a href="#四、运算符的优先级和结合性" class="headerlink" title="四、运算符的优先级和结合性"></a>四、运算符的优先级和结合性</h3><ol><li><p>按照<strong>优先级</strong>从高到低，即最前面，数字越小的优先级越高，越优先算。</p><table border="0" cellpadding="0" cellspacing="0" width="550" style="border-collapse: collapse;table-layout:fixed;width:413pt"> <colgroup><col width="81" style="mso-width-source:userset;mso-width-alt:2581;width:61pt"> <col width="77" style="mso-width-source:userset;mso-width-alt:2474;width:58pt"> <col width="88" style="mso-width-source:userset;mso-width-alt:2816;width:66pt"> <col width="155" style="mso-width-source:userset;mso-width-alt:4949;width:116pt"> <col width="80" style="mso-width-source:userset;mso-width-alt:2560;width:60pt"> <col width="69" style="width:52pt"> </colgroup><tbody><tr height="19" style="height:14.5pt">  <td height="19" class="xl65" width="81" style="height:14.5pt;width:61pt;box-sizing: border-box">优先级</td>  <td class="xl66" width="77" style="border-left:none;width:58pt;box-sizing: border-box">运算符</td>  <td class="xl66" width="88" style="border-left:none;width:66pt;box-sizing: border-box">名称或含义</td>  <td class="xl66" width="155" style="border-left:none;width:116pt;box-sizing: border-box">使用形式</td>  <td class="xl66" width="80" style="border-left:none;width:60pt;box-sizing: border-box">结合方向</td>  <td class="xl67" width="69" style="border-left:none;width:52pt;box-sizing: border-box">说明</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="4" height="76" class="xl68" width="81" style="height:58.0pt;border-top:  none;width:61pt">1</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp; &nbsp;[]</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">数组下标</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">数组名[长度]</td>  <td rowspan="4" class="xl68" width="80" style="border-top:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">　</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt">（）</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">小括号</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt">(<font class="font7">表达式</font><font class="font5">)</font><font class="font7">或函数名</font><font class="font5">(</font><font class="font7">形参表</font><font class="font5">)</font></td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">　</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; .</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">取成员</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">结构体名.成员</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt">　</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; -&gt;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">指针</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">结构体指针-&gt;成员</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt">　</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="9" height="171" class="xl68" width="81" style="height:130.5pt;  border-top:none;width:61pt">2</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp; -</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">负号运算符</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">-表达式</td>  <td rowspan="9" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从右往左</td>  <td rowspan="2" class="xl69" width="69" style="border-top:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">（）</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">强制类型转换</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">(数据类型)表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; ++</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">自增运算符</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">++变量或变量++</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; --</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">自减运算符</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">--变量或变量--</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; *</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">取内容</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">*指针变量</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; &amp;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">取地址</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">&amp;变量名</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; ！</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">逻辑非</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">!表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; ~</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位取反</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">~整型表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; sizeof</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">求长度</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt">sizeof(表达式)</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">单目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="3" height="57" class="xl68" width="81" style="height:43.5pt;border-top:  none;width:61pt">3</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp;/</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">除</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式 / 表达式</td>  <td rowspan="3" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp;*</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">乘</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式 * 表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; %</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">取余</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式 / 表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="2" height="38" class="xl68" width="81" style="height:29.0pt;border-top:  none;width:61pt">4</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp;+</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">加</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式+表达式</td>  <td rowspan="2" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp; -</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">减</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式-表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="2" height="38" class="xl68" width="81" style="height:29.0pt;border-top:  none;width:61pt">5</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&lt;&lt;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">左移</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量&lt;&lt;表达式</td>  <td rowspan="2" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&gt;&gt;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">右移</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量&lt;&lt;表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="4" height="76" class="xl68" width="81" style="height:58.0pt;border-top:  none;width:61pt">6</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&gt;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">大于</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式&gt;表达式</td>  <td rowspan="4" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&gt;=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">大于或等于</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式&gt;=表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&lt;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">小于</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式&lt;表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&lt;=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">小于或等于</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式&lt;=表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="2" height="38" class="xl68" width="81" style="height:29.0pt;border-top:  none;width:61pt">7</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp;==</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">等于</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式==表达式</td>  <td rowspan="2" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&nbsp;!=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">不等于</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式!=表达式</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="81" style="height:14.5pt;border-top:none;  width:61pt;box-sizing: border-box">8</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp; &amp;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位与</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式&amp;表达式</td>  <td class="xl68" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="81" style="height:14.5pt;border-top:none;  width:61pt;box-sizing: border-box">9</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp; ^</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位异或</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式^表达式</td>  <td class="xl68" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右&nbsp;</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="81" style="height:14.5pt;border-top:none;  width:61pt;box-sizing: border-box">10</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&nbsp; |</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位或</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式|表达式</td>  <td class="xl68" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="81" style="height:14.5pt;border-top:none;  width:61pt;box-sizing: border-box">11</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">&amp;&amp;</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">逻辑与</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式&amp;&amp;表达式</td>  <td class="xl68" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="81" style="height:14.5pt;border-top:none;  width:61pt;box-sizing: border-box">12</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">||</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">逻辑或</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式||表达式</td>  <td class="xl68" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="81" style="height:14.5pt;border-top:none;  width:61pt;box-sizing: border-box">13</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">？：</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">条件运算符</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式1? 表达式2: 表达式3</td>  <td class="xl68" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从右往左</td>  <td class="xl69" width="69" style="border-top:none;border-left:none;width:52pt;  box-sizing: border-box">三目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td rowspan="11" height="209" class="xl68" width="81" style="height:159.5pt;  border-top:none;width:61pt">14</td>  <td class="xl68" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">赋值运算符</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量=表达式</td>  <td rowspan="11" class="xl68" width="80" style="border-top:none;width:60pt">&nbsp;  从右往左</td>  <td rowspan="12" class="xl69" width="69" style="border-bottom:1.0pt solid black;  border-top:none;width:52pt;box-sizing: border-box">双目运算符</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">/=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">除后再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量/=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">*=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">乘后再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量*=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">%=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">取余后再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量%=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">+=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">加后再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量+=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">-=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">减后再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量-=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&lt;&lt;=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">左移再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量&lt;&lt;=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&gt;&gt;=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">右移再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量&gt;&gt;=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">&amp;=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位与再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量&amp;=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">^=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位异或再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量^=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl68" width="77" style="height:14.5pt;border-top:none;  border-left:none;width:58pt;box-sizing: border-box">|=</td>  <td class="xl68" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">按位或再赋值</td>  <td class="xl68" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">变量|=表达式</td> </tr> <tr height="19" style="height:14.5pt">  <td height="19" class="xl72" width="81" style="height:14.5pt;border-top:none;  width:61pt">15</td>  <td class="xl72" width="77" style="border-top:none;border-left:none;width:58pt;  box-sizing: border-box">,</td>  <td class="xl72" width="88" style="border-top:none;border-left:none;width:66pt;  box-sizing: border-box">逗号表达式</td>  <td class="xl72" width="155" style="border-top:none;border-left:none;width:116pt;  box-sizing: border-box">表达式,表达式,…</td>  <td class="xl72" width="80" style="border-top:none;border-left:none;width:60pt;  box-sizing: border-box">&nbsp; 从左往右</td> </tr> <!--[if supportMisalignedColumns]--> <tr height="0" style="display:none">  <td width="81" style="width:61pt"></td>  <td width="77" style="width:58pt"></td>  <td width="88" style="width:66pt"></td>  <td width="155" style="width:116pt"></td>  <td width="80" style="width:60pt"></td>  <td width="69" style="width:52pt"></td> </tr> <!--[endif]--></tbody></table></li></ol><h2 id="第五章-C程序流"><a href="#第五章-C程序流" class="headerlink" title="第五章 C程序流"></a>第五章 C程序流</h2><h3 id="一、选择（分支）结构"><a href="#一、选择（分支）结构" class="headerlink" title="一、选择（分支）结构"></a>一、选择（分支）结构</h3><ol><li><p><code>if()</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">if(表达式) /*如果表达式成立，执行语句1否则继续判断表达式2*/ {     //语句1 } else if(表达式2) /*如果表达式成立，执行语句2否则继续判断表达式3*/ {     //语句2 } else if(表达式3) /*如果表达式成立，则执行语句3否则继续判断下一个表达式*/ {     //语句3; } //… … else /*如果以上表达式都不成立 则执行语句4*/ {     //语句4 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>switch case语句</code></p><p>switch语句的执行过程为：首先计算表达式的值，然后依次与常量表达式依次进行比较，若表达式的值与某常量表达式相等，则从该常量表达式处开始执行，直到switch语句结束。若所有的常量表达式的值均不等于表达式的值，则从default处开始执行。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">switch(表达式) /*首先计算表达式的值*/ {     case 常量表达式1:语句1;     case 常量表达式2:语句2;     // ……     case 常量表达式n:语句n;     default:语句n+1;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>break语句</code></p><p><strong>break</strong>，跳出的意思，仅用于跳出<strong>switch结构</strong>或<strong>循环结构</strong>，用于提前结束switch结构或循环。</p></li></ol><h3 id="二、循环结构"><a href="#二、循环结构" class="headerlink" title="二、循环结构"></a>二、循环结构</h3><ol><li><p><code>while()循环</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">while(表达式) //为真进入循环{     循环体语句 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>do while()循环</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">do {     循环体语句 //循环至少要被执行一次}while(表达式);//为真循环<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>for()循环</code></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">for(初始化表达式;判断表达式;更新表达式){    循环体语句 }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>九九乘法表</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(void){    int i, j;    for ( i = 1; i &lt;= 9; i++)    {        for(j = 1; j &lt;= 9; j++)        {            printf("%d*%d=%-2d ",j,i,i*j);            if(i == j)            break;        }        printf("\n");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>continue语句</code></p><p><strong>continue</strong>，顾名思义是继续的意思，它仅用于循环中，用于<strong>提前结束本次循环</strong>，即跨过continue后面的循环语句，提前进入下次循环。</p><p>continue语句并不能像break那样可以在switch和循环中都可以使用，continue只能在循环中使用！除非switch也在循环中。</p></li></ol><h2 id="第六章-C函数"><a href="#第六章-C函数" class="headerlink" title="第六章 C函数"></a>第六章 C函数</h2><h3 id="一、C语言函数"><a href="#一、C语言函数" class="headerlink" title="一、C语言函数"></a>一、C语言函数</h3><ol><li><p>函数定义</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">返回值类型 函数名(形参表说明) /*函数首部*/{    说明语句 /*函数体*/    执行语句}//函数返回值不能是数组，也不能是函数;//函数类型可以省略，当不指明函数类型时，系统默认的是整型//函数名本身也有值，它代表了该函数的入口地址，使用指针调用函数时，将用到此功能<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>函数调用</p><p>在主调函数中调用某函数之前应对该被调函数进行声明，在主调函数中对被调函数进行声明的目的是使编译系统知道被调函数返回值的类型，以便在主调函数中按此种类型对返回值进行相应的处理。其一般形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">类型说明符 被调函数名(类型 形参,类型 形参...);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>函数的声明</strong>和<strong>函数的定义</strong>有本质上的不同，主要区别在以下两个方面：</p><p>(1)函数的定义是编写一段程序，应有函数的具体功能语句——<strong>函数体</strong>，而函数的声明仅是向编译系统的一个说明，不含具体的执行动作。<br>(2)在程序中，函数的定义只能有一次，而函数的声明可以有多次。</p></li></ol><h3 id="二、C语言变量的存储类型"><a href="#二、C语言变量的存储类型" class="headerlink" title="二、C语言变量的存储类型"></a>二、C语言变量的存储类型</h3><ol><li><p><strong>变量</strong>是对程序中数据所占内存空间的一种抽象定义，定义变量时，用户定义变量的名、变量的类型。</p></li><li><p>在计算机中，保存变量当前值的<strong>存储单元</strong>有两类，一类是内存，另一类是CPU的寄存器。</p></li><li><p>变量的存储类型关系到变量的存储位置，C语言中定义了<code>4种存储属性(类型)</code>，即自动变量(auto)、外部变量(extern)、静态变量(static)和寄存器变量(register)，它关系到变量在内存中的存放位置，由此决定了变量的保留时间和变量的作用范围。</p></li><li><p>变量的保留时间又称为<strong>生存期</strong>，从时间角度，可将变量分为<strong>静态存储</strong>和<strong>动态存储</strong>两种情况：</p><p>（1）<strong>静态存储</strong>是指变量存储在内存的静态存储区，在编译时就分配了存储空间，在整个程序的运行期间，该变量占有固定的存储单元，程序结束后，这部分空间才释放，变量的值在整个程序中始终存在。</p><p>（2）<strong>动态存储</strong>是指变量存储在内存的动态存储区，在程序的运行过程中，只有当变量所在的函数被调用时，编译系统才临时为该变量分配一段内存单元，函数调用结束，该变量空间释放，变量的值只在函数调用期存在。</p></li><li><p>变量的作用范围又称为<strong>作用域</strong>，从空间角度，可以将变量分为<strong>全局变量</strong>和<strong>局部变量</strong>：</p><p>（1）<strong>局部变量</strong>是在一个函数或复合语句内定义的变量，它仅在函数或复合语句内有效，编译时，编译系统不为局部变量分配内存单元，而是在程序运行过程中，当局部变量所在的函数被调用时，编译系统根据需要，临时分配内存，调用结束，空间释放。</p><p>（2）<strong>全局变量</strong>是在函数之外定义的变量，其作用范围为从定义处开始到本文件结束，编译时，编译系统为其分配固定的内存单元，在程序运行的自始至终都占用固定单元。</p></li><li><p><code>auto自动变量类型</code></p><p><strong>自动变量</strong><br>函数中的局部变量，如不专门声明为static存储类别，都是动态地分配存储空间的，数据存储在动态存储区中。函数中的形参和在函数中定义的变量（包括在复合语句中定义的变量）都属此类，在调用该函数时系统会给它们分配存储空间，在函数调用结束时就自动释放这些存储空间，这类局部变量称为<strong>自动变量</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fun(int a){    auto int b,c=3;/*定义b,c为自动变量*/}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><code>extern外部变量</code></p><p><strong>外部变量</strong>，即<strong>全局变量</strong>，是在函数的外部定义的，它的作用域为从变量定义处开始，到本程序文件的末尾。如果外部变量不在文件的开头定义，其有效的作用范围只限于定义处到文件末尾。</p><ul><li><p>如果在定义点之前的函数想引用该外部变量，则应该在引用之前用<strong>关键字extern</strong>对该变量进行“外部变量声明”，表示该变量是一个已经定义的外部变量。有了此声明，就可以从“声明”处起，合法地使用该外部变量。</p></li><li><p>通常的，用extern声明外部变量，扩展程序文件中的作用域。</p></li></ul></li><li><p><code>static静态变量</code></p><p>有时希望函数中的局部变量的值在函数调用结束后不消失而保留原值，这时就应该指定局部变量为<strong>静态局部变量</strong>，用<strong>关键字static</strong>进行声明。</p><ul><li><p>通过用static类型声明后的变量，其变量的内存空间位于内存的全局静态区，仅会<strong>初始化一次</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;static a=5;int fun(){    a=a*2;    printf("a=%d\n",a);    return 0;}int main(){    int i=0;    for(i=0;i&lt;3;i++)    {        fun();    }    return 0;}/*a=10a=20a=40   每次a的值是接着上一次函数调用的值继续运算的，并非每次都初始化从5开始计算，这就是static的特性*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p><code>register寄存器变量</code></p><p>为提高效率，C语言允许将局部变量的值存放在CPU的寄存器中，这种变量叫做<strong>寄存器变量</strong>，用<strong>关键字register</strong>声明。使用寄存器变量需要注意以下几点：</p><ul><li><p>只有局部自动变量和形式参数可以作为寄存器变量。</p></li><li><p>一个计算机系统中的寄存器数目有限，不能定义任意多个寄存器变量。</p></li><li><p>不能使用取地址运算符“&amp;”求寄存器变量的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">register int a=0;//将变量a存储在寄存器上<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul></li></ol><h2 id="第七章-C数组"><a href="#第七章-C数组" class="headerlink" title="第七章 C数组"></a>第七章 C数组</h2><h3 id="一、一维数组"><a href="#一、一维数组" class="headerlink" title="一、一维数组"></a>一、一维数组</h3><ol><li><p>定义和使用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">类型说明符 数组名 [常量表达式];//其中类型说明符是任意一种基本数据类型或构造数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当在函数中只定义数组时，数组里的值都是未初始化过的，可以定义时初始化赋值，并且，当给部分元素赋初值的时候，未被赋值的元素将自动赋值为0，具体地，int类型未被赋值的元素为0，浮点型为小数类型，而字符类型则为’\0’。</p></li></ol><h3 id="二、二维数组"><a href="#二、二维数组" class="headerlink" title="二、二维数组"></a>二、二维数组</h3><ol><li><p>定义和使用</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">类型说明符 数组名[行数][列数];int a[3][4]; /*定义一个整形二维数组a，有3行4列共12个元素分别为：a[0][0] a[0][1] a[0][2] a[0][3]a[1][0] a[1][1] a[1][2] a[1][3]a[2][0] a[2][1] a[2][2] a[2][3]*/char arry[10][10]; //定义一个字符型二维数组arry，有10行10列，依次为arry[0][0]~arry[9][9]共100个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>初始化并赋值</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[3][4]={{1,2,3,4},{10,20,30,40},{100,200,300,400}}; //定义一个三行四列的二维数组，按行赋值int a[3][4]={1,2,3,4,10,20,30,40,100,200,300,400}; //定义一个三行四列的二维数组并对其中的12（3*4）个元素进行赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>两种赋值方式可知：二维数组与一维数组一样在内存中的存储也是按照线性排布的。</p></li></ol><h3 id="三、字符数组和字符串"><a href="#三、字符数组和字符串" class="headerlink" title="三、字符数组和字符串"></a>三、字符数组和字符串</h3><ol><li><p>用来存放字符的数组称为<strong>字符数组</strong>。字符数组的各个元素依次存放字符串的各字符，字符数组的数组名代表该数组的<strong>首地址</strong>，这为处理字符串中个别字符和引用整个字符串提供了极大的方便。</p></li><li><p>字符数组的定义和初始化</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char c[6]={'c', ' h ', 'i', 'n', 'a' , '\0' };//对字符数组的各个元素逐个赋值后，各元素的值为：c[0]= 'c',c[1]= 'h',c[2]= 'i',c[3]= 'n',c[4]= 'a',c[5]= '\0';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>其中,<code>\0</code>为<strong>字符串结束符</strong>。如果不对c[5]赋任何值，‘\0’会由系统自动添加。字符数组也可采用字符串常量的赋值方式，</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char a[]={"china"};<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="第八章-C语言指针"><a href="#第八章-C语言指针" class="headerlink" title="第八章 C语言指针"></a>第八章 C语言指针</h2><h3 id="一、指针和地址"><a href="#一、指针和地址" class="headerlink" title="一、指针和地址"></a>一、指针和地址</h3><ol><li><p>指针也就是内存地址，指针变量是用来存放内存地址的变量，在同一CPU构架下，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。有了指针以后，不仅可以对数据本身，也可以对存储数据的变量地址进行操作。</p></li><li><p><strong>地址</strong>：在内存，这里提到的内存并不是人们常说的计算机的物理内存，而是虚拟的逻辑内存空间中，地址常用其对应的十六进制数来表示，比如0x12ff7c。C程序中，每一个定义的变量，在内存中都占有一个内存单元，比如int类型占四个字节，char类型占一个字节等。C语言允许在程序中使用变量的地址，并可以通过地址运算符”&amp;”得到变量的地址。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(){           int i;           int a[10]={1,2,3,4,5,6,7,8,9,0};           char b[10]={'c','l','a','n','g','u','a','g','e'};           for(i=0;i&lt;10;i++)           {                       printf("int Address:0x%x,Value:%d\n",&amp;a[i],a[i]);          }           printf("\n");           for(i=0;i&lt;10;i++)           {                       printf("char Address:0x%x,Value :%c\n",&amp;b[i],b[i]);           }           return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、指针的定义和使用"><a href="#二、指针的定义和使用" class="headerlink" title="二、指针的定义和使用"></a>二、指针的定义和使用</h3><ol><li><p>地址就是逻辑内存上的编号，而指针虽然也表示一个编号，也是一个地址。但两者性质却不相同。一个代表了常量，另一个则是变量。</p></li><li><p>就好比内存是一把尺子，而指针就是尺子上面的游标，可以左右移动，它某一个时刻是指向一个地方的，这就是<strong>指针变量</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">类型说明符 *变量名;/*'*'与前面的类型说明符共同说明这是一个指针变量类型说明符表示该指针变量所指向的变量为何种数据类型，变量名即为定义的指针变量名。除此之外，C还提供*运算符获取地址上对应的值*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>通过数组下标可以确定数组元素在数组中的<strong>顺序</strong>和<strong>存储地址</strong>。每个数组元素相当于一个变量，因此<strong>指针变量</strong>可以指向数组中的元素，也就是说可以用指针方式访问数组中的元素。</p><p>对一个指向数组元素的指针变量的定义和赋值方法，与指针变量相同，例如：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int a[10]; /*定义a为包含10个整型数据的数组*/int *p; /*定义p为指向整型变量的指针*/p=&amp;a[0]; /*把a[0]元素的地址赋给指针变量p*/p=a; /*等价于p=&amp;a[0];*/int *p=a; /*等价于int *p=&amp;a[0];数组名代表数组的首地址，也就是第0号元素的地址*///对于指向首地址的指针p，p+i(或a+i)就是数组元素a[i]的地址，*(p+i)(或*(a+i))就是a[i]的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>指针变量p已指向数组中的某一个元素，则p+1指向同一数组中的下一个元素。</p></li><li><p>引入指针变量后，就可以用以下两种方法来访问<strong>数组元素</strong>：</p><ul><li><p><strong>下标法</strong>，即用a[i]形式访问数组元素</p></li><li><p><strong>指针法</strong>，即采用<code>*(a+i)</code>或<code>*(p+i)</code>形式，用间接访问的方法来访问数组元素，其中a是数组名，p是指向数组的指针变量，其初值p=a。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(void){    int a[10] = {1,2,3,4,5,6,7,8,9,0};    int *p = a;    for (int i = 0; i &lt; 10; i++)    {        //printf("P value : %d, A value : %d\n", p[i], a[i]);        //printf("P value : %d, A value : %d\n", *(p++), a[i]);printf("P value : %d, A value : %d\n", *(p++), *(a+i));    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针可以通过++或–并修改自身值的方式移动，然而数组名本身值不可以被更改。</p></li></ul></li></ol><h3 id="三、字符串与指针"><a href="#三、字符串与指针" class="headerlink" title="三、字符串与指针"></a>三、字符串与指针</h3><ol><li><p><strong>字符指针</strong>也可以指向一个字符串，可以用字符串常量对字符指针进行<strong>初始化</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *str = "www.dotcpp.com";//字符指针指向一个字符串常量的首地址。char strin[ ] = "Welcome to dotcpp.com";//字符数组来存放字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>字符串指针和字符串数组两种方式都可以访问字符串</p><p>本质的区别：</p><ul><li><p>字符指针str是个变量，可以改变str使它指向不同的字符串，但<strong>不能改变str所指向的字符串常量的值</strong>。</p></li><li><p>而strin是一个数组，可以改变数组中保存的内容。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(){    char *str = "www.dotcpp.com";    char string[]="Welcome to dotcpp.com";    str[0]='C'; //试图修改str指向的常量区的字符串内容，改不了    strin[0]='H';//可以改    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>字符串处理函数，声明<code>#include&lt;string.h&gt;</code></p><p><code>strcpy()</code>函数：将一个字符串指针拷贝到一个字符串数组中 </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *strcpy(char *destin, const char *source);//destin只能是字符数组，而不能是字符串指针指向的字符串，因为字符串指针指向的是字符串常量，常量不能被修改char string[10];char *str1 = "www.dotcpp.com";strcpy(string, str1);printf("%s\n", string);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>strcat()</code>函数：将一个字符串拼接在目标字符串的后面</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">char *strcat(char *destin, const char *source);//destin只能是字符数组，而不能是字符串指针指向的字符串，因为字符串指针指向的是字符串常量，常量不能被修改char destination[25]={"I love"};char *blank = " ", *c = "www.dotcpp.com";strcat(destination, blank);strcat(destination, c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>strcpm()</code>函数：比较两个字符串的大小，区分大小写</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int strcmp(const char *str1,const char *str2);/*str1 &gt; str2 , 返回 1；  str1 &lt; str2 , 返回 -1；  str1 == str2 , 返回 0；*/char *buf1 = "aaa", *buf2 = "bbb", *buf3 = "ccc";int ptr = strcmp(buf2, buf1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>strlen()</code>函数：计算字符串长度</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int strlen(const char *str);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="第九章-结构体和共同体"><a href="#第九章-结构体和共同体" class="headerlink" title="第九章 结构体和共同体"></a>第九章 结构体和共同体</h2><h3 id="一、结构体"><a href="#一、结构体" class="headerlink" title="一、结构体"></a>一、结构体</h3><ol><li><p><strong>结构体的定义</strong>说明了它的组成成员，以及每个成员的数据类型。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct 结构类型名 {     数据类型 成员名 1;     数据类型 成员名 2;     ......     数据类型 成员名 n; };//所占内存大小为结构中每个成员的长度之和。struct 结构类型名称 结构变量名;struct 结构类型名 结构变量 = { 初始化数据 1, ...... 初始化数据 n };<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体数组是一个数组，其数组的每一个元素都是<strong>结构体类型</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct address{    char name[30]; /*姓名，字符数组作为结构体中的成员*/    char street[40]; /*街道*/    unsigned long tel; /*电话，无符号长整型作为结构体中的成员*/    unsigned long zip; /*邮政编码*/}student[3]={    {"Zhang","Road NO.1",111111,4444},    {"Wang"," Road NO.2",222222,5555},    {"Li"," Road NO.3",333333,6666}};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体指针即指向结构体的指针。</p><p>当一个指针用来指向一个结构体变量时，称之为<strong>结构体指针变量</strong>。结构体指针变量中的值是所指向的结构变量的首地址，通过结构指针即可访问该结构变量。这与数组指针和函数指针的情况是相同的。结构体指针变量定义的一般形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">struct 结构类型名 *结构指针变量名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>结构体变量用点<code>.</code>来访问成员的方法，结构体指针是通过箭头<code>-&gt;</code>来访问的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;struct address{    char name[30]; /*姓名，字符数组作为结构体中的成员*/    char street[40]; /*街道*/    unsigned long tel; /*电话，无符号长整型作为结构体中的成员*/    unsigned long zip; /*邮政编码*/};int main(){    struct address A[3]={{"Zhang","Road NO.1",111111,4444},    {"Wang"," Road NO.2",222222,5555},    {"Li"," Road NO.3",333333,6666}};    struct address *p;    p=&amp;A[0];    printf("%s %s %u %u\n",p-&gt;name,p-&gt;street,p-&gt;tel,p-&gt;zip);    return 0;    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="二、共同体"><a href="#二、共同体" class="headerlink" title="二、共同体"></a>二、共同体</h3><ol><li><p>允许几种不同类型的变量存放到同一段内存单元中，也就是使用<strong>覆盖技术</strong>，几个变量互相覆盖。这种几个不同的变量共同占用一段内存的结构，被称为<strong>共用体类型结构</strong>，简称<strong>共用体</strong>。一般定义形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">union 共用体名 {     数据类型 成员名 1;     数据类型 成员名 2;     ......     数据类型 成员名 n; }变量名表列;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>共用体类型数据具有以下<strong>特点</strong>：</p><ul><li>同一个内存段可以用来存放几种不同类型的成员，但是在每一瞬间只能存放其中的一种，而不是同时存放几种。换句话说，每一瞬间只有一个成员起作用，其他的成员不起作用，即不是同时都存在和起作用的；</li><li>共用体变量中起作用的成员是最后一次存放的成员，在存入一个新成员后，原有成员就失去作用；</li><li>共用体变量的地址和它的各成员的地址都是同一地址。</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;union INFO{    int a;    int b;    int c;};int main(){    union INFO A;    A.a=1;    A.b=2;    A.c=3;    printf("a:%d\n",A.a);    printf("b:%d\n",A.b);    printf("c:%d\n",A.c);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>不能在定义共用体变量时对它进行初始化。</strong></p></li><li><p>不能把共用体变量作为函数参数，也不能是函数返回共用体变量，但可以使用指向共用体变量的指针。</p></li><li><p>共用体类型可以出现在结构体类型的定义中，也可以定义<strong>共用体数组</strong>。反之，结构体也可以出现在共用体类型的定义中，数组也可以作为共用体的成员。</p></li></ol><h3 id="三、typedef用法和enum枚举类型"><a href="#三、typedef用法和enum枚举类型" class="headerlink" title="三、typedef用法和enum枚举类型"></a>三、typedef用法和enum枚举类型</h3><ol><li><p>使用类型说明语句typedef定义新的类型来代替已有的类型。typedef语句的一般形式是：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef 已定义的类型 新的类型;typedef int INTEGER; /*指定用 INTEGER 代表 int 类型*/typedef float REAL; /*指定用 REAL 代表 float 类型*/int i, j; /*与 INTEGER i,j;*/float pi; /*与 REAL pi;*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>typedef的最常用的作用就是给<strong>结构体变量</strong>重命名。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">typedef struct _INFO{    int num;    char str[256];}INFO;struct _INFO A = {24, "guluyu"};INFO B; //通过typedef重命名后的名字INFO与struct _INFO完全等价！B = A;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>结构体变量和结构体变量可以相互赋值，共用体也可相互赋值。</p></li><li><p>enum<strong>枚举类型</strong>，它可以让代码更简介、更易读。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">enum　枚举名　{枚举元素1,枚举元素2,……};//定义了一个“枚举名”的枚举类型，其值为枚举元素1（即0）、枚举元素2（即1）...（依次递增）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>枚举类型每个元素的值是从0开始递增的。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">enum Week{MON, TUE, WED, THU, FRI, SAT, SUN};//定义一个enum week类型，七个值（0.1.2...6）enum Week A = WED; //第三个值赋给Aprintf("%d\n",A);  //输出2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>枚举类型的特点默认是<strong>从0开始递增</strong>，若想更改，可以将其中某个类型赋值，后面的值将在此基础之上递增，如代码：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">enum Week2{MON, TUE=5, WED, THU, FRI, SAT, SUN};enum Week2 B = MON;//输出0enum Week2 C = WED;//输出6printf("%d\n",B);printf("%d\n",C);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>此时用宏定义（后面讲到）实现将更麻烦，因此枚举的优势就在于此。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;int main(void){    enum week{Monday, Tuesday, Wednesday, Thursady, Friday, Saturday, Sunday} day;        scanf("%d",&amp;day);    switch(day)    {        case Monday: puts("Monday"); break;        case Tuesday: puts("Tuesday"); break;        case Wednesday: puts("Wednesday"); break;        case Thursady: puts("Thursday"); break;        case Friday: puts("Friday"); break;        case Saturday: puts("Saturday"); break;        case Sunday: puts("Sunday"); break;        default: puts("input error!");    }    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="第十章-文件操作"><a href="#第十章-文件操作" class="headerlink" title="第十章 文件操作"></a>第十章 文件操作</h2><h3 id="一、fopen-函数"><a href="#一、fopen-函数" class="headerlink" title="一、fopen()函数"></a>一、<code>fopen()</code>函数</h3><ol><li><p><code>fopen()</code>函数：<strong>打开文件</strong>，获取该文件的文件指针，方便后续操作。函数原型为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE *fopen(const char *filename, const char *mode);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>函数的返回值则表示打开成功后的文件指针，格式为<strong>FILE类型</strong>，是一个结构体类型，供后面使用，如果打开失败，则返回NULL。</p><p>第一个是<strong>文件名</strong>，既要操作的文件对象。第二个是<strong>打开方式</strong>，指对文件以何种模式打开，包括文本模式打开还是二进制打开、读还是写还是追加等，具体类型如下表，可以根据情况使用：</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">以只读方式打开文件，该文件必须存在。</td></tr><tr><td align="center">r+</td><td align="center">以读/写方式打开文件，该文件必须存在。</td></tr><tr><td align="center">rb+</td><td align="center">以读/写方式打开一个二进制文件，只允许读/写数据。</td></tr><tr><td align="center">rt+</td><td align="center">以读/写方式打开一个文本文件，允许读和写。</td></tr><tr><td align="center">w</td><td align="center">打开只写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td></tr><tr><td align="center">w+</td><td align="center">打开可读/写文件，若文件存在则文件长度清为零，即该文件内容会消失；若文件不存在则创建该文件。</td></tr><tr><td align="center">a</td><td align="center">以附加的方式打开只写文件。若文件不存在，则会创建该文件；如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF 符保留）。</td></tr><tr><td align="center">a+</td><td align="center">以附加方式打开可读/写的文件。若文件不存在，则会创建该文件，如果文件存在，则写入的数据会被加到文件尾后，即文件原先的内容会被保留（EOF符不保留）。</td></tr><tr><td align="center">wb</td><td align="center">以只写方式打开或新建一个二进制文件，只允许写数据。</td></tr><tr><td align="center">wb+</td><td align="center">以读/写方式打开或新建一个二进制文件，允许读和写。</td></tr><tr><td align="center">wt+</td><td align="center">以读/写方式打开或新建一个文本文件，允许读和写。</td></tr><tr><td align="center">at+</td><td align="center">以读/写方式打开一个文本文件，允许读或在文本末追加数据。</td></tr><tr><td align="center">ab+</td><td align="center">以读/写方式打开一个二进制文件，允许读或在文件末追加数据。</td></tr></tbody></table></li><li><p>如果我们现在想打开一个D盘根目录下的abc.dat，并且想读出该文件里的数据</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE *fp;fp=fopen("d:\\abc.dat","r")//后面通过fp指针开始读文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>说明：</p><ul><li>该文件的目录是绝对路径，因此这样写，如果不写盘符比如abc.dat则表示相对路径，表示与本程序同目录下。</li><li>路径中的反斜杠虽然只有一个，但这里打了两个，原因在于C语言字符串中对反斜杠要当作<strong>转义字符</strong>处理，因此要用两个反斜杠才能表示一个。</li><li>一旦以r也就是只读的方式打开文件，后面则不允许写数据，否则会出错，一定要保持一致！</li></ul></li></ol><h3 id="二、fprintf-函数"><a href="#二、fprintf-函数" class="headerlink" title="二、fprintf()函数"></a>二、<code>fprintf()</code>函数</h3><ol><li><p><code>fprintf()</code>函数：打开模式是写，那么可以用<strong>fprintf函数</strong>来进行写。(<strong>写入</strong>)</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fprintf (FILE* stream, const char*format, [argument])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>该函数是一个格式化写入的库函数，可以看到，除了长得和printf函数很像以外，参数也非常像，多了一个第一个参数<strong>文件指针</strong>，即第一步打开文件时得到的文件指针，后面的参数和printf一样，按照指定的格式将数据写入文件。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">fprintf(fp,"%s","https://nusqx.github.io/");//将字符串"https://nusqx.github.io/"以%s的格式写入fp所指向的文件中。//返回值为整型，如果写入成功则返回写入字符的格式，否则返回一个负数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">控制符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">%c</td><td align="center">字符</td></tr><tr><td align="center">%d 或 %i</td><td align="center">有符号十进制整数</td></tr><tr><td align="center">%e</td><td align="center">使用 e 字符的科学科学记数法（尾数和指数）</td></tr><tr><td align="center">%E</td><td align="center">使用 E 字符的科学科学记数法（尾数和指数）</td></tr><tr><td align="center">%f</td><td align="center">十进制浮点数</td></tr><tr><td align="center">%g</td><td align="center">自动选择 %e 或 %f 中合适的表示法</td></tr><tr><td align="center">%G</td><td align="center">自动选择 %E 或 %f 中合适的表示法</td></tr><tr><td align="center">%o</td><td align="center">有符号八进制</td></tr><tr><td align="center">%s</td><td align="center">字符的字符串</td></tr><tr><td align="center">%u</td><td align="center">无符号十进制整数</td></tr><tr><td align="center">%x</td><td align="center">无符号十六进制整数</td></tr><tr><td align="center">%X</td><td align="center">无符号十六进制整数（大写字母）</td></tr><tr><td align="center">%p</td><td align="center">指针地址</td></tr><tr><td align="center">%n</td><td align="center">无输出</td></tr><tr><td align="center">%</td><td align="center">字符</td></tr></tbody></table></li></ol><h3 id="三、fscanf函数"><a href="#三、fscanf函数" class="headerlink" title="三、fscanf函数"></a>三、<code>fscanf</code>函数</h3><ol><li><p><code>fscanf</code>函数：从文件里读数据。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fscanf(FILE *stream, char *format[,argument...]);//第一个参数文件指针，表示读取的文件目标，其余参数和scanf一样，按照相应的格式进行读取，返回值表示读取数据的字节数。char str[100];fscanf(fp,"%s",str);//从fp所指向的文件中进行读数据，与空格或换行结束，将结果保存到str数组中。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">格式</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">%d</td><td align="center">读入一个十进制整数</td></tr><tr><td align="center">%i</td><td align="center">读入十进制，八进制，十六进制整数，与%d类似，但是在编译时通过数据前置或后置来区分进制，如加入“0x”则是十六进制，加入“0”则为八进制。例如串“031”使用%d时会被算作31，但是使用%i时会算作25</td></tr><tr><td align="center">%u</td><td align="center">读入一个无符号十进制整数</td></tr><tr><td align="center">%f %F %g %G</td><td align="center">用来输入实数，可以用小数形式或指数形式输入</td></tr><tr><td align="center">%x %x</td><td align="center">读入十六进制整数</td></tr><tr><td align="center">%o</td><td align="center">读入八进制整数</td></tr><tr><td align="center">%s</td><td align="center">直到遇到一个空格字符（空格字符可以是空白、换行和制表符）</td></tr><tr><td align="center">%c</td><td align="center">单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符</td></tr></tbody></table></li></ol><h3 id="四、fwrite-函数"><a href="#四、fwrite-函数" class="headerlink" title="四、fwrite()函数"></a>四、<code>fwrite()</code>函数</h3><ol><li><p><code>fwrite()</code>函数：写文件的函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个ptr是要写入的数据的<strong>头指针</strong>，无符号类型；</p><p>第二个参数size是<strong>大小</strong>，表示每个写入元素的大小，单位是字节；</p><p>第三个参数nmemb是<strong>个数</strong>，以上一个参数为单位的个数；</p><p>第四个参数stream就是<strong>文件指针</strong>，表示往哪里写。</p><p>返回值，如果成功执行，则返回写入元素的个数，如果不和nmemb相等，则表示出错。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">FILE *fp;   char str[] = "https://nusqx.github.io/"; fp = fopen( "guluyu.txt" , "w" );   fwrite(str, sizeof(str) , 1, fp ); //将str字符串中的一个字节写入到文件中fclose(fp);  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="五、fread-函数"><a href="#五、fread-函数" class="headerlink" title="五、fread()函数"></a>五、<code>fread()</code>函数</h3><ol><li><p><code>fread()</code>函数：读文件的函数。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>第一个参数ptr表示盛放内容的<strong>首地址</strong>；</p><p>第二个参数size表示每个元素的<strong>大小</strong>，单位还是字节；</p><p>第三个参数nmem表示要读取的<strong>元素个数</strong>；</p><p>第四个参数stream表示的是<strong>文件指针</strong>，即从哪个文件中读取。</p><p>返回值则是表示读取元素的个数，与nmemb一致表示读取成功，否则失败。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include &lt;stdio.h&gt;int main(){   FILE *fp;   char buffer[100]; /* 首先打开文件，读写都可以，假设文件中已经有内容为www.dotcpp.com */   fp = fopen("dotcpp.dat", "a+");   /* 读取并显示数据 */   fread(buffer, 1, 16, fp);   printf("%s\n", buffer);   fclose(fp);   return(0);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="六、fclose-函数"><a href="#六、fclose-函数" class="headerlink" title="六、fclose()函数"></a>六、<code>fclose()</code>函数</h3><ol><li><p><code>fclose()</code>函数：断开程序与文件关联，切断IO数据流，释放文件不在占用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">int fclose( FILE *fp );<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>返回值为<strong>整型</strong>，如成功关闭则返回0，失败则返回-1。</p></li></ol><h2 id="第十一章-C语言预处理"><a href="#第十一章-C语言预处理" class="headerlink" title="第十一章 C语言预处理"></a>第十一章 C语言预处理</h2><p>C语言提供的预处理功能有三种，分别为宏定义、文件包含和条件编译。</p><h3 id="一、宏定义define"><a href="#一、宏定义define" class="headerlink" title="一、宏定义define"></a>一、宏定义<code>define</code></h3><ol><li><p>用一个标识符来表示一个字符串，称为“宏”，被定义为“宏”的标识符称为“宏名”。</p></li><li><p>在编译预处理时，对程序中所有出现的宏名，都用宏定义中的字符串去代换，这称为“宏代换”或“宏展开”。宏定义是由源程序中的宏定义命令完成的，宏代换是由预处理程序自动完成的。</p></li><li><p>在C语言中，宏分为有参数和无参数两种。无参宏的宏名后不带参数，其定义的一般形式为：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#define 标识符 字符串;//“define”为宏定义命令，“标识符”为所定义的宏名，“字符串”可以是常数、表达式、格式串等。#define M (y*y+3*y);//标识符M来代替表达式(y*y+3*y)。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>“#”表示这是一条预处理命令</p></li><li><p>在宏定义中的参数称为形式参数，在宏调用中的参数称为实际参数。对于带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。</p></li><li><pre><code class="c">#define 宏名(形参表) 字符串;宏名(实参表);//调用#define M(y) y*y+3*y   /*宏定义*/#define MAX(a,b) (a&gt;b)?a:bk=M(5); /*宏调用*/int x = 5, y = 9;int max = MAX(x,y);<pre class="line-numbers language-none"><code class="language-none">7. 宏替换相当于实现了一个函数调用的功能，而事实上，与函数调用相比，宏调用更能提高C程序的执行效率。### 二、include文件包含1. 文件包含是C预处理程序的另一个重要功能，文件包含命令行的一般形式为：   ```c   #include "文件名"   #include &lt;文件名&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><p>文件包含命令的功能是把指定的文件插入该命令行位置取代该命令行，从而把指定的文件和当前的源程序文件连成一个源文件。</p></li><li><p>一个大的程序可以分为多个模块，由多个程序员分别编程，有些公用的符号常量或宏定义等可单独组成一个文件，在其他文件的开头用包含命令包含该文件即可使用。这样，可避免在每个文件开头都去书写那些公用量，从而节省时间，并减少出错。</p></li><li><p>文件包含说明：</p><ul><li>包含命令中的文件名可以用<strong>双引号</strong>引起来，也可以用<strong>尖括号</strong>引起来；<ul><li>区别：使用<strong>尖括号</strong>表示在包含文件目录中去查找（包含目录是由系统的环境变量进行设置的，一般为系统头文件的默认存放目录，比如Linux系统在/usr/include目录下），而不在源文件的存放目录中查找；使用<strong>双引号</strong>则表示首先在当前的源文件目录中查找，若未找到才到包含目录中去查找。用户编程时可根据自己文件所在的目录来选择某一种命令形式。</li></ul></li><li>一个include命令只能指定<strong>一个被包含文件</strong>，若有多个文件要包含，则需用多个include命令；</li><li>文件包含允许<strong>嵌套</strong>，即在一个被包含的文件中又可以包含另一个文件。</li></ul></li></ol><h3 id="三、条件编译"><a href="#三、条件编译" class="headerlink" title="三、条件编译"></a>三、条件编译</h3><ol><li><p><strong>预处理程序</strong>提供了条件编译的功能，可以按不同的条件去编译不同的程序部分，因而产生不同的<strong>目标代码文件</strong>，这对于程序的移植和调试是很有用的。<strong>条件编译</strong>可分为三种形式。</p></li><li><p>第一种形式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#ifdef 标识符程序段 1#else程序段 2#endif//功能是如果标识符已被#define命令定义过则对程序段1进行编译；否则对程序段2进行编译。   <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果没有程序段2（为空），本格式中的#else可以没有，即可以写为： </p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#ifdef 标识符程序段#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p>第二种形式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#ifndef 标识符程序段 1#else程序段 2#endif//“ifdef”改为“ifndef”。它的功能是如果标识符未被#define命令定义过则对程序段1进行编译，否则对程序段2进行编译。这与第一种形式的功能正好相反。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>第三种形式如下：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#if 常量表达式程序段 1#else程序段 2#endif//功能是如果常量表达式的值为真（非0），则对程序段1进行编译，否则对程序段2进行编译。因此可以使程序在不同的条件下完成不同的功能。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="四、其他预处理命令"><a href="#四、其他预处理命令" class="headerlink" title="四、其他预处理命令"></a>四、其他预处理命令</h3><ol><li><p><code>#error</code>：强制编译程序停止编译，它主要用于<strong>程序调试</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#error error-message/*宏串error-message不用双引号引起来。遇到#error指令时，错误信息被显示，可能同时还显示编译程序作者预先定义的其他内容。*/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><code>#line</code>：改变<code>__LINE__</code>和<code>__FILE__</code>的内容。<code>__LINE__</code>和<code>__FILE__</code>都是编译程序中<strong>预定义</strong>的标识符。<code>__FILE__</code>的内容是当前被编译源文件的文件名。<code>__LINE__</code>的内容是当前被编译代码行的行号。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#line number "filename"//number是正整数并变成_LINE_的新值；可选的“filename”是合法文件标识符并变成__FILE__的新值。#line主要用于调试和特殊应用。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><code>#pragma</code>：编译程序实现时定义的指令，它允许由此向编译程序传入各种指令。</p></li></ol><p>   例如：一个编译程序可能具有支持跟踪程序执行的选项，此时可以用#pragma语句选择该功能，编译程序忽略其不支持的#pragma选项。使用#pragma预处理命令可提高C源程序对编译程序的可移植性。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#define swap(a,b) {t=a;a=b;b=t;}//宏定义，交换 #define MAX(a,b,c) (a&gt;b?a:b)&gt;c?(a&gt;b?a:b):cint main(void){int a,b,t;printf("输入两个数：\n");scanf("%d%d",&amp;a,&amp;b);//输入 printf("输出结果：\n");swap(a,b);//两个数进行交换 printf("%d %d",a,b);//输出    return 0;  } <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><strong>一、数据类型关键字</strong></p><p><strong>a. 基本数据类型（5个）</strong></p><p>void：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果。</p><p>char：字符型类型数据，属于整型数据的一种。</p><p>int：整型数据，通常为编译器指定的机器字长。</p><p>float：单精度浮点型数据，属于浮点数据的一种。</p><p>double：双精度浮点型数据，属于浮点数据的一种。</p><p><strong>b. 类型修饰关键字（4个）</strong></p><p>short：修饰int，短整型数据，可省略被修饰的int。</p><p>long：修饰int，长整形数据，可省略被修饰的int。</p><p>signed：修饰整型数据，有符号数据类型。</p><p>unsigned：修饰整型数据，无符号数据类型。</p><p><strong>c. 复杂类型关键字（5个）</strong></p><p>struct：结构体声明。</p><p>union：共用体声明。</p><p>enum：枚举声明。</p><p>typedef：声明类型别名。</p><p>sizeof：得到特定类型或特定类型变量的大小。</p><p><strong>d. 存储级别关键字（6个）</strong></p><p>auto：指定为自动变量，由编译器自动分配及释放，通常在栈上分配。</p><p>static：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部。</p><p>register：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数。</p><p>extern：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的对象的一个“引用“</p><p>const：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）。</p><p>volatile：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值。</p><p><strong>二、流程控制关键字</strong></p><p><strong>a. 跳转结构（4个）</strong></p><p>return：用在函数体中，返回特定值（或者是void值，即不返回值）。</p><p>continue：结束当前循环，开始下一轮循环。</p><p>break：跳出当前循环或switch结构。</p><p>goto：无条件跳转语句。</p><p><strong>b. 分支结构（5个）</strong></p><p>if：条件语句。</p><p>else：条件语句否定分支（与if连用）。</p><p>switch：开关语句（多重分支语句）。</p><p>case：开关语句中的分支标记。</p><p>default：开关语句中的“其他”分治，可选。</p><p><strong>c. 循环结构（3个）</strong></p><p>for：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件。</p><p>do：do循环结构，do 1 while(2);的执行顺序是1-&gt;2-&gt;1…循环，2为循环条件。</p><p>while：while循环结构，while(1) 2;的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件。</p><p>以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。</p><p><strong>注：</strong></p><ol><li><p>C语言中没有字符串即string类型，所以要想在C语言中使用字符串，需要使用字符数组表示，而相关的字符串处理函数就要在头文件里定义#include&lt;string.h&gt;（引用）。</p></li><li><p>main也不是关键字，仅仅是编译器指定的函数入口而已。</p></li><li><p>include也不是关键字，而是通过#打头的预处理命令而已。</p></li></ol><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/09/07/hello-world/"/>
      <url>/2018/09/07/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new "My New Post"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="文章配置"><a href="#文章配置" class="headerlink" title="文章配置"></a>文章配置</h3><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p><strong>注意</strong>:</p><ol><li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章的特色图<strong>各有特色</strong>。</li><li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol><h3 id="hexo中使用思维导图"><a href="#hexo中使用思维导图" class="headerlink" title="hexo中使用思维导图"></a>hexo中使用思维导图</h3><p>使用 Hexo 的 pullquote 将思维导图的内容包裹起来，mindmap 是思维导图渲染的标志，尺寸有三种规格：</p><ul><li>mindmap-sm</li><li>mindmap-md</li><li>mindmap-lg</li></ul><blockquote class="pullquote mindmap mindmap-sm"><ul><li><a href="https://hunterx.xyz/use-mindmap-in-hexo.html">在 Hexo 中使用思维导图</a><ul><li>前言</li><li>操作指南<ul><li>准备需要的文件</li><li>为主题添加 CSS/JS 文件</li></ul></li><li>使用方法<ul><li>左分支</li></ul></li></ul></li></ul></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
